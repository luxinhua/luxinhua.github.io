{"meta":{"title":"XINHUALU'S BLOG","subtitle":"","description":"","author":"XinHua Lu","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-02-07T21:03:27.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"books","date":"2021-02-07T21:03:20.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-02-07T21:01:18.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2021-02-07T21:03:27.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"repository","date":"2021-02-07T21:03:12.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-02-07T21:00:10.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"BiosInterFace update 的思路","slug":"bios/06_Biso_interface_update","date":"2021-03-09T10:47:23.651Z","updated":"2021-03-09T10:47:23.651Z","comments":true,"path":"2021/03/09/bios/06_Biso_interface_update/","link":"","permalink":"http://example.com/2021/03/09/bios/06_Biso_interface_update/","excerpt":"","text":"概念 PMFW专门控制CLK/power的一个bin , SMUBIOS的菜单控制，设置值，分发值到具体的模块SMU和PMFW通过msg机制更新biosinterfaceTable的结构体来通信。 MSG机制一端，向某个寄存器写入消息ID，消息参数，poll 等待response，另一端是硬件中断，拿到硬件中断后，处理写入response消息。","categories":[{"name":"bios","slug":"bios","permalink":"http://example.com/categories/bios/"}],"tags":[]},{"title":"gdb 调试常用命令备忘","slug":"tool/gdb","date":"2021-03-09T00:00:00.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"2021/03/09/tool/gdb/","link":"","permalink":"http://example.com/2021/03/09/tool/gdb/","excerpt":"","text":"disassemble //gdb下使用可以查看汇编代码disassemble /m 函数名 /m 源码和汇编一起排列disassemble 不带参数，默认的反汇编范围是 所选择帧的pc附近的函数单个参数, 就是pc, 当然也可以是函数名，因为函数名 也是一个 地址; 这样范围就是该pc附近的函数两个参数，就是内存地址范围 使用display /i $pc（结合display命令和寄存器/pc内部变量）指令进行设置 info register查看寄存器的情况，可以简写成i r主要是%eip、%eax、%esp和%ebp 列出的结果主要有三行 最左边是寄存器名称外，中间是寄存器存的值（也就是一个内存地址），右边是这个值对应的内存 地址中的值。打印一下$eax可验证 si，ni： 下一条语句遇到函数调用的时候，nexti不会跟踪进入函数，而是继续执行下面的语句， 而step命令则会跟踪进入函数内部。 si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指 令，而s/n针对的是源代码。 i代表指令（instruction） n(ext)i s(tep)i $pc 代表pc程序计数器的值 set disassembly-flavor intel gdb设置intel汇编 ，默认是att print其实是有计数器的，每次print打印，其实都有一个类似count++在内部发生，使用print $num 能显示第num个打印结果，如上，p $3 //查看第三个值 (gdb)p i (gdb)p/a i (gdb)p/c i (gdb)p/f i (gdb)p/x i (gdb)p/o i (gdb)p/d i (gdb)p/t i f浮点，c字符，t为二进制，o八，x十六，d十 a和x同样是打印十六进制,不同名但同功能 调试运行中的程序： #ps -aux | grep execFile //找到运行中的进程PID， 使用 #gdb execFile PID bt n(next)往下走是看不到已经运行完的错误的，所以就谈到bt（backtrace）命令——回溯。info line main //查看main的信息 info line 0x… //查看某一行信息r是run的缩写 r 参数 以参数运行程序quit,退出gdb调试gdb -q 程序名 //这个操作可以不输出一些信息（gdb的一些版本信息说明之类的） gdb也支持运行linux命令的，可以在gdb的提示符中，输入shell，然后在输入你需要的命令就可以了。例如：shell clear 清屏b*0x… //在逆向调试的时候，在某行指令下断点必须遵照这个格式 x/i 可以查看指令 例如： x/15i main 查看main函数中的第15条指令 x/43bc 0xffffd190 指的是 0xffffd190后43个内存单元 想边看汇编变调试就先：r 参数 ，然后使用layout asm，直接动态显示指令运行 layout 几个参数： src : Displays source and command windows. asm : Displays disassembly and command windows. split : Displays source, disassembly and command windows. regs : Displays register window. If existing layout c（continue） 可以让程序执行到下一个断点处 p $eax 查看寄存器的值 x/i $pc 查看当前指令的运行地址修改寄存器值的两种方式(想要满足某个比较条件直接修改寄存器，可以跳到想跳的地方)： 1)直接来： set $eax=value 2)找到寄存器的地址通过这个地址修改值： p $rsp+0x714 set *上一步的值=value x/ &lt;n/f/u&gt; //内存地址中的值，x即examine,3个参数顺序可变 1)n是一个正整数，表示需要显示的内存单元的个数 2)f表示显示的格式（有以下选项）： x （hexadecimal）按十六进制格式显示变量。 d （signed decimal）按十进制格式显示变量。 u （unsigned decimal）按十进制格式显示无符号整型。 o （octal）按八进制格式显示变量。 t （binary）按二进制格式显示变量。 a （address）按十六进制格式显示地址，并显示距离前继符号的偏移量(offset)。常用于定位未知 地址(变量)。 c （character）按字符格式显示变量。 f （floating）按浮点数格式显示变量。 3)u表示从当前地址往后请求的字节数单位，如果不指定的话，GDB默认是4个bytes： b表示单字节， h表示双字节， w表示四字节， g表示八字节 x/10x $sp–&gt;打印stack的前10个元素 reverse-stepi //回退一条指令info thread // 查看所有线程 continue 执行到下一暂停点或程序结束。next 执行一行源代码但不进入函数内部。step 执行一行源代码而且进入函数内部。gdb 运行程序例子程序名为prog，则在终端输入 gdb proggdb 设置参数set args 可指定运行时参数。（如：set args 10 20 30 40 50） show args 命令可以查看设置好的运行参数。 若要再次修改参数，可再执行一遍 set args运行输入 r 运行 出错后，输入 bt 查看运行堆栈退出输入 quit","categories":[{"name":"tools","slug":"tools","permalink":"http://example.com/categories/tools/"}],"tags":[]},{"title":"hack binary example","slug":"liveoverflow/镜像加密验证例子","date":"2021-03-09T00:00:00.000Z","updated":"2021-03-09T10:47:23.651Z","comments":true,"path":"2021/03/09/liveoverflow/镜像加密验证例子/","link":"","permalink":"http://example.com/2021/03/09/liveoverflow/%E9%95%9C%E5%83%8F%E5%8A%A0%E5%AF%86%E9%AA%8C%E8%AF%81%E4%BE%8B%E5%AD%90/","excerpt":"","text":"","categories":[{"name":"liveoverflow","slug":"liveoverflow","permalink":"http://example.com/categories/liveoverflow/"}],"tags":[]},{"title":"c 函数参数是怎么传递的，整个过程","slug":"liveoverflow/c_example_param","date":"2021-03-08T00:00:00.000Z","updated":"2021-03-09T10:47:23.651Z","comments":true,"path":"2021/03/08/liveoverflow/c_example_param/","link":"","permalink":"http://example.com/2021/03/08/liveoverflow/c_example_param/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276xinhualu@BU-build-XHLU /cygdrive/c/Users/xinhualu/Desktop/pri_xx/test$ cat main.c#include &lt;stdio.h&gt;int test2(int a, int b , int c, int d , int e)&#123; printf(&quot;%d, %d, %d, %d, %d\\n&quot;, a,b,c,d,e); return 0;&#125;int test(int a, int b , int c, int d , int e)&#123; test2(6,7,8,9,10); printf(&quot;%d, %d, %d, %d, %d\\n&quot;, a,b,c,d,e); return 0;&#125;int main(int argc,char *argv[])&#123; test(1,2,3,4,5); return 0;&#125;xinhualu@BU-build-XHLU /cygdrive/c/Users/xinhualu/Desktop/pri_xx/test$ vim main.cxinhualu@BU-build-XHLU /cygdrive/c/Users/xinhualu/Desktop/pri_xx/test$ gdb a.exeGNU gdb (GDB) (Cygwin 9.2-1) 9.2Copyright (C) 2020 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type &quot;show copying&quot; and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-pc-cygwin&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...Reading symbols from a.exe...(gdb) b main.c:16Breakpoint 1 at 0x10040114b: file main.c, line 16.(gdb) rStarting program: /cygdrive/c/Users/xinhualu/Desktop/pri_xx/test/a.exe[New Thread 8624.0xf8][New Thread 8624.0x2404][New Thread 8624.0x1560][New Thread 8624.0x13b0]Thread 1 &quot;a&quot; hit Breakpoint 1, main (argc=1, argv=0xffffcc60) at main.c:1616 test(1,2,3,4,5);(gdb) disassembleDump of assembler code for function main: 0x0000000100401137 &lt;+0&gt;: push %rbp 0x0000000100401138 &lt;+1&gt;: mov %rsp,%rbp 0x000000010040113b &lt;+4&gt;: sub $0x30,%rsp 0x000000010040113f &lt;+8&gt;: mov %ecx,0x10(%rbp) 0x0000000100401142 &lt;+11&gt;: mov %rdx,0x18(%rbp) 0x0000000100401146 &lt;+15&gt;: callq 0x100401190 &lt;__main&gt;=&gt; 0x000000010040114b &lt;+20&gt;: movl $0x5,0x20(%rsp) 0x0000000100401153 &lt;+28&gt;: mov $0x4,%r9d 0x0000000100401159 &lt;+34&gt;: mov $0x3,%r8d 0x000000010040115f &lt;+40&gt;: mov $0x2,%edx 0x0000000100401164 &lt;+45&gt;: mov $0x1,%ecx 0x0000000100401169 &lt;+50&gt;: callq 0x1004010ca &lt;test&gt; 0x000000010040116e &lt;+55&gt;: mov $0x0,%eax 0x0000000100401173 &lt;+60&gt;: add $0x30,%rsp 0x0000000100401177 &lt;+64&gt;: pop %rbp 0x0000000100401178 &lt;+65&gt;: retqEnd of assembler dump.(gdb) stest (a=1, b=2, c=3, d=4, e=5) at main.c:1010 test2(6,7,8,9,10);(gdb) l5 printf(&quot;%d, %d, %d, %d, %d\\n&quot;, a,b,c,d,e);6 return 0;7 &#125;89 int test(int a, int b , int c, int d , int e)&#123;10 test2(6,7,8,9,10);11 printf(&quot;%d, %d, %d, %d, %d\\n&quot;, a,b,c,d,e);12 return 0;13 &#125;14(gdb) disassembleDump of assembler code for function test: 0x00000001004010ca &lt;+0&gt;: push %rbp 0x00000001004010cb &lt;+1&gt;: mov %rsp,%rbp 0x00000001004010ce &lt;+4&gt;: sub $0x30,%rsp 0x00000001004010d2 &lt;+8&gt;: mov %ecx,0x10(%rbp) 0x00000001004010d5 &lt;+11&gt;: mov %edx,0x18(%rbp) 0x00000001004010d8 &lt;+14&gt;: mov %r8d,0x20(%rbp) 0x00000001004010dc &lt;+18&gt;: mov %r9d,0x28(%rbp)=&gt; 0x00000001004010e0 &lt;+22&gt;: movl $0xa,0x20(%rsp) 0x00000001004010e8 &lt;+30&gt;: mov $0x9,%r9d 0x00000001004010ee &lt;+36&gt;: mov $0x8,%r8d 0x00000001004010f4 &lt;+42&gt;: mov $0x7,%edx 0x00000001004010f9 &lt;+47&gt;: mov $0x6,%ecx 0x00000001004010fe &lt;+52&gt;: callq 0x100401080 &lt;test2&gt; 0x0000000100401103 &lt;+57&gt;: mov 0x20(%rbp),%ecx 0x0000000100401106 &lt;+60&gt;: mov 0x18(%rbp),%edx 0x0000000100401109 &lt;+63&gt;: mov 0x30(%rbp),%eax 0x000000010040110c &lt;+66&gt;: mov %eax,0x28(%rsp) 0x0000000100401110 &lt;+70&gt;: mov 0x28(%rbp),%eax 0x0000000100401113 &lt;+73&gt;: mov %eax,0x20(%rsp) 0x0000000100401117 &lt;+77&gt;: mov %ecx,%r9d 0x000000010040111a &lt;+80&gt;: mov %edx,%r8d 0x000000010040111d &lt;+83&gt;: mov 0x10(%rbp),%edx 0x0000000100401120 &lt;+86&gt;: lea 0x1ed9(%rip),%rcx # 0x100403000 0x0000000100401127 &lt;+93&gt;: callq 0x1004011a0 &lt;printf&gt; 0x000000010040112c &lt;+98&gt;: mov $0x0,%eax 0x0000000100401131 &lt;+103&gt;: add $0x30,%rsp 0x0000000100401135 &lt;+107&gt;: pop %rbp 0x0000000100401136 &lt;+108&gt;: retqEnd of assembler dump.(gdb) s[New Thread 8624.0x1d34]test2 (a=6, b=7, c=8, d=9, e=10) at main.c:55 printf(&quot;%d, %d, %d, %d, %d\\n&quot;, a,b,c,d,e);(gdb) disassembleDump of assembler code for function test2: 0x0000000100401080 &lt;+0&gt;: push %rbp 0x0000000100401081 &lt;+1&gt;: mov %rsp,%rbp 0x0000000100401084 &lt;+4&gt;: sub $0x30,%rsp 0x0000000100401088 &lt;+8&gt;: mov %ecx,0x10(%rbp) 0x000000010040108b &lt;+11&gt;: mov %edx,0x18(%rbp) 0x000000010040108e &lt;+14&gt;: mov %r8d,0x20(%rbp) 0x0000000100401092 &lt;+18&gt;: mov %r9d,0x28(%rbp)=&gt; 0x0000000100401096 &lt;+22&gt;: mov 0x20(%rbp),%ecx 0x0000000100401099 &lt;+25&gt;: mov 0x18(%rbp),%edx 0x000000010040109c &lt;+28&gt;: mov 0x30(%rbp),%eax 0x000000010040109f &lt;+31&gt;: mov %eax,0x28(%rsp) 0x00000001004010a3 &lt;+35&gt;: mov 0x28(%rbp),%eax 0x00000001004010a6 &lt;+38&gt;: mov %eax,0x20(%rsp) 0x00000001004010aa &lt;+42&gt;: mov %ecx,%r9d 0x00000001004010ad &lt;+45&gt;: mov %edx,%r8d 0x00000001004010b0 &lt;+48&gt;: mov 0x10(%rbp),%edx 0x00000001004010b3 &lt;+51&gt;: lea 0x1f46(%rip),%rcx # 0x100403000 0x00000001004010ba &lt;+58&gt;: callq 0x1004011a0 &lt;printf&gt; 0x00000001004010bf &lt;+63&gt;: mov $0x0,%eax 0x00000001004010c4 &lt;+68&gt;: add $0x30,%rsp 0x00000001004010c8 &lt;+72&gt;: pop %rbp 0x00000001004010c9 &lt;+73&gt;: retqEnd of assembler dump.(gdb) n[New Thread 8624.0x24b0]6, 7, 8, 9, 106 return 0;(gdb) disassembleDump of assembler code for function test2: 0x0000000100401080 &lt;+0&gt;: push %rbp 0x0000000100401081 &lt;+1&gt;: mov %rsp,%rbp 0x0000000100401084 &lt;+4&gt;: sub $0x30,%rsp 0x0000000100401088 &lt;+8&gt;: mov %ecx,0x10(%rbp) 0x000000010040108b &lt;+11&gt;: mov %edx,0x18(%rbp) 0x000000010040108e &lt;+14&gt;: mov %r8d,0x20(%rbp) 0x0000000100401092 &lt;+18&gt;: mov %r9d,0x28(%rbp) 0x0000000100401096 &lt;+22&gt;: mov 0x20(%rbp),%ecx 0x0000000100401099 &lt;+25&gt;: mov 0x18(%rbp),%edx 0x000000010040109c &lt;+28&gt;: mov 0x30(%rbp),%eax 0x000000010040109f &lt;+31&gt;: mov %eax,0x28(%rsp) 0x00000001004010a3 &lt;+35&gt;: mov 0x28(%rbp),%eax 0x00000001004010a6 &lt;+38&gt;: mov %eax,0x20(%rsp) 0x00000001004010aa &lt;+42&gt;: mov %ecx,%r9d 0x00000001004010ad &lt;+45&gt;: mov %edx,%r8d 0x00000001004010b0 &lt;+48&gt;: mov 0x10(%rbp),%edx 0x00000001004010b3 &lt;+51&gt;: lea 0x1f46(%rip),%rcx # 0x100403000 0x00000001004010ba &lt;+58&gt;: callq 0x1004011a0 &lt;printf&gt;=&gt; 0x00000001004010bf &lt;+63&gt;: mov $0x0,%eax 0x00000001004010c4 &lt;+68&gt;: add $0x30,%rsp 0x00000001004010c8 &lt;+72&gt;: pop %rbp 0x00000001004010c9 &lt;+73&gt;: retqEnd of assembler dump.(gdb) n7 &#125;(gdb) l234 int test2(int a, int b , int c, int d , int e)&#123;5 printf(&quot;%d, %d, %d, %d, %d\\n&quot;, a,b,c,d,e);6 return 0;7 &#125;89 int test(int a, int b , int c, int d , int e)&#123;10 test2(6,7,8,9,10);11 printf(&quot;%d, %d, %d, %d, %d\\n&quot;, a,b,c,d,e);(gdb) disassembleDump of assembler code for function test2: 0x0000000100401080 &lt;+0&gt;: push %rbp 0x0000000100401081 &lt;+1&gt;: mov %rsp,%rbp 0x0000000100401084 &lt;+4&gt;: sub $0x30,%rsp 0x0000000100401088 &lt;+8&gt;: mov %ecx,0x10(%rbp) 0x000000010040108b &lt;+11&gt;: mov %edx,0x18(%rbp) 0x000000010040108e &lt;+14&gt;: mov %r8d,0x20(%rbp) 0x0000000100401092 &lt;+18&gt;: mov %r9d,0x28(%rbp) 0x0000000100401096 &lt;+22&gt;: mov 0x20(%rbp),%ecx 0x0000000100401099 &lt;+25&gt;: mov 0x18(%rbp),%edx 0x000000010040109c &lt;+28&gt;: mov 0x30(%rbp),%eax 0x000000010040109f &lt;+31&gt;: mov %eax,0x28(%rsp) 0x00000001004010a3 &lt;+35&gt;: mov 0x28(%rbp),%eax 0x00000001004010a6 &lt;+38&gt;: mov %eax,0x20(%rsp) 0x00000001004010aa &lt;+42&gt;: mov %ecx,%r9d 0x00000001004010ad &lt;+45&gt;: mov %edx,%r8d 0x00000001004010b0 &lt;+48&gt;: mov 0x10(%rbp),%edx 0x00000001004010b3 &lt;+51&gt;: lea 0x1f46(%rip),%rcx # 0x100403000 0x00000001004010ba &lt;+58&gt;: callq 0x1004011a0 &lt;printf&gt; 0x00000001004010bf &lt;+63&gt;: mov $0x0,%eax=&gt; 0x00000001004010c4 &lt;+68&gt;: add $0x30,%rsp 0x00000001004010c8 &lt;+72&gt;: pop %rbp 0x00000001004010c9 &lt;+73&gt;: retqEnd of assembler dump.(gdb) ntest (a=1, b=2, c=3, d=4, e=5) at main.c:1111 printf(&quot;%d, %d, %d, %d, %d\\n&quot;, a,b,c,d,e);(gdb) disassembleDump of assembler code for function test: 0x00000001004010ca &lt;+0&gt;: push %rbp 0x00000001004010cb &lt;+1&gt;: mov %rsp,%rbp 0x00000001004010ce &lt;+4&gt;: sub $0x30,%rsp 0x00000001004010d2 &lt;+8&gt;: mov %ecx,0x10(%rbp) 0x00000001004010d5 &lt;+11&gt;: mov %edx,0x18(%rbp) 0x00000001004010d8 &lt;+14&gt;: mov %r8d,0x20(%rbp) 0x00000001004010dc &lt;+18&gt;: mov %r9d,0x28(%rbp) 0x00000001004010e0 &lt;+22&gt;: movl $0xa,0x20(%rsp) 0x00000001004010e8 &lt;+30&gt;: mov $0x9,%r9d 0x00000001004010ee &lt;+36&gt;: mov $0x8,%r8d 0x00000001004010f4 &lt;+42&gt;: mov $0x7,%edx 0x00000001004010f9 &lt;+47&gt;: mov $0x6,%ecx 0x00000001004010fe &lt;+52&gt;: callq 0x100401080 &lt;test2&gt;=&gt; 0x0000000100401103 &lt;+57&gt;: mov 0x20(%rbp),%ecx 0x0000000100401106 &lt;+60&gt;: mov 0x18(%rbp),%edx 0x0000000100401109 &lt;+63&gt;: mov 0x30(%rbp),%eax 0x000000010040110c &lt;+66&gt;: mov %eax,0x28(%rsp) 0x0000000100401110 &lt;+70&gt;: mov 0x28(%rbp),%eax 0x0000000100401113 &lt;+73&gt;: mov %eax,0x20(%rsp) 0x0000000100401117 &lt;+77&gt;: mov %ecx,%r9d 0x000000010040111a &lt;+80&gt;: mov %edx,%r8d 0x000000010040111d &lt;+83&gt;: mov 0x10(%rbp),%edx 0x0000000100401120 &lt;+86&gt;: lea 0x1ed9(%rip),%rcx # 0x100403000 0x0000000100401127 &lt;+93&gt;: callq 0x1004011a0 &lt;printf&gt; 0x000000010040112c &lt;+98&gt;: mov $0x0,%eax 0x0000000100401131 &lt;+103&gt;: add $0x30,%rsp 0x0000000100401135 &lt;+107&gt;: pop %rbp 0x0000000100401136 &lt;+108&gt;: retqEnd of assembler dump.(gdb) n1, 2, 3, 4, 512 return 0;(gdb) n13 &#125;(gdb) nmain (argc=1, argv=0xffffcc60) at main.c:1717 return 0;(gdb) disassembleDump of assembler code for function main: 0x0000000100401137 &lt;+0&gt;: push %rbp 0x0000000100401138 &lt;+1&gt;: mov %rsp,%rbp 0x000000010040113b &lt;+4&gt;: sub $0x30,%rsp 0x000000010040113f &lt;+8&gt;: mov %ecx,0x10(%rbp) 0x0000000100401142 &lt;+11&gt;: mov %rdx,0x18(%rbp) 0x0000000100401146 &lt;+15&gt;: callq 0x100401190 &lt;__main&gt; 0x000000010040114b &lt;+20&gt;: movl $0x5,0x20(%rsp) 0x0000000100401153 &lt;+28&gt;: mov $0x4,%r9d 0x0000000100401159 &lt;+34&gt;: mov $0x3,%r8d 0x000000010040115f &lt;+40&gt;: mov $0x2,%edx 0x0000000100401164 &lt;+45&gt;: mov $0x1,%ecx 0x0000000100401169 &lt;+50&gt;: callq 0x1004010ca &lt;test&gt;=&gt; 0x000000010040116e &lt;+55&gt;: mov $0x0,%eax 0x0000000100401173 &lt;+60&gt;: add $0x30,%rsp 0x0000000100401177 &lt;+64&gt;: pop %rbp 0x0000000100401178 &lt;+65&gt;: retqEnd of assembler dump.(gdb)","categories":[{"name":"liveoverflow","slug":"liveoverflow","permalink":"http://example.com/categories/liveoverflow/"}],"tags":[]},{"title":"vscode 插件记录","slug":"vscode/插件","date":"2021-03-02T00:00:00.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"2021/03/02/vscode/插件/","link":"","permalink":"http://example.com/2021/03/02/vscode/%E6%8F%92%E4%BB%B6/","excerpt":"","text":"scope4code ccls c/c++ eclipse keymap git history gitlens","categories":[{"name":"vscode","slug":"vscode","permalink":"http://example.com/categories/vscode/"}],"tags":[]},{"title":"C 的角角落落","slug":"c/c角角落落","date":"2021-03-02T00:00:00.000Z","updated":"2021-03-09T10:47:23.651Z","comments":true,"path":"2021/03/02/c/c角角落落/","link":"","permalink":"http://example.com/2021/03/02/c/c%E8%A7%92%E8%A7%92%E8%90%BD%E8%90%BD/","excerpt":"","text":"asm volatile(“”: : :”memory”) // 强制每次都从内存中读取数据，不优化。 memory 强制gcc编译器假设RAM所有内存单元均被汇编指令修改，这样cpu中的registers和cache中已缓存的内存单元中的数据将作废。cpu将不得不在需要的时候重新读取内存中的数据。这就阻止了cpu又将registers，cache中的数据用于去优化指令，而避免去访问内存。 __asm__用于指示编译器在此插入汇编语句。 __volatile__用于告诉编译器，严禁将此处的汇编语句与其它的语句重组合优化。即：原原本本按原来的样子处理这这里的汇编。 memory强制gcc编译器假设RAM所有内存单元均被汇编指令修改，这样cpu中的registers和cache中已缓存的内存单元中的数据将作废。cpu将不得不在需要的时候重新读取内存中的数据。这就阻止了cpu又将registers，cache中的数据用于去优化指令，而避免去访问内存。 “”:::表示这是个空指令。barrier()不用在此插入一条串行化汇编指令。 section 段的方式访问函数 将我需要用到的函数放在 .mywon 段中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;unistd.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;typedef void (*myown_call)(void);extern myown_call _myown_start;extern myown_call _myown_end;#define _init __attribute__((unused, section(&quot;.myown&quot;)))#define func_init(func) myown_call _fn_##func _init = funcstatic void mspec1(void)&#123; write(1, &quot;aha!\\n&quot;, 5);&#125;static void mspec2(void)&#123; write(1, &quot;aloha!\\n&quot;, 7);&#125;static void mspec3(void)&#123; write(1, &quot;hello!\\n&quot;, 7);&#125;func_init(mspec1);func_init(mspec2);func_init(mspec3);/* exactly like below:static myown_call mc1 __attribute__((unused, section(&quot;.myown&quot;))) = mspec1;static myown_call mc2 __attribute__((unused, section(&quot;.myown&quot;))) = mspec2;static myown_call mc3 __attribute__((unused, section(&quot;.myown&quot;))) = mspec3;*/void do_initcalls(void)&#123; myown_call *call_ptr = &amp;_myown_start; do &#123; fprintf (stderr, &quot;call_ptr: %p\\n&quot;, call_ptr); (*call_ptr)(); ++call_ptr; &#125; while (call_ptr &lt; &amp;_myown_end);&#125;int main(void)&#123; do_initcalls(); return 0;&#125;","categories":[{"name":"c","slug":"c","permalink":"http://example.com/categories/c/"}],"tags":[]},{"title":"PCI 设备访问","slug":"pci_device/pci_device","date":"2021-02-22T00:00:00.000Z","updated":"2021-03-09T10:47:23.651Z","comments":true,"path":"2021/02/22/pci_device/pci_device/","link":"","permalink":"http://example.com/2021/02/22/pci_device/pci_device/","excerpt":"","text":"win 10 列出PCI设备 1wmic path win32_pnpentity where &quot;deviceid like &#x27;%PCI%&#x27;&quot; get name,deviceid","categories":[{"name":"PCI","slug":"PCI","permalink":"http://example.com/categories/PCI/"}],"tags":[]},{"title":"UEFI --- PCD 语法","slug":"uefi/uefi_pcd","date":"2021-02-22T00:00:00.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"2021/02/22/uefi/uefi_pcd/","link":"","permalink":"http://example.com/2021/02/22/uefi/uefi_pcd/","excerpt":"","text":"PCD 1TokenSpaceGuidCName.PcdCName TokenSpaceGuidCName是一个GUID，PcdCName是一个变量名，两者合起来构成了唯一的PCD变量 PCD 变量有如下类型 （ 主要是访问方式不同 ）： FeatureFlag PCD：它最终返回的是一个TRUE或者FALSE，用于判断条件中；123456[PcdsFeatureFlag] gUefiOemPkgTokenSpaceGuid.PcdTestFeatureVar|FALSE|BOOLEAN|0x30000001访问： DEBUG ((EFI_D_ERROR, &quot;[beni]PcdTestBooleanVar: %d\\n&quot;, FeaturePcdGet (PcdTestFeatureVar)));DEBUG ((EFI_D_ERROR, &quot;[beni]PcdTestBooleanVar: %d\\n&quot;, PcdGetBool (PcdTestFeatureVar))); PatchableInModule PCD：这种变量的值可以在编译的时候确定，这个不算特别，特别的是它可以在编译完成的二进制文件上通过工具来修改值；1234[PcdsPatchableInModule]gUefiOemPkgTokenSpaceGuid.PcdPatchableVar|0x00ABCDEF|UINT32|0x50000001DEBUG ((EFI_D_ERROR, &quot;[beni]PcdPatchableVar: 0x%x\\n&quot;, PcdGet32 (PcdPatchableVar))); FixedAtBuild PCD：静态值，在编译的时候确定，整个UEFI阶段不可变；1234567891011[PcdsFixedAtBuild]gUefiOemPkgTokenSpaceGuid.PcdTestVar1|0xA5|UINT8|0x20000001gUefiOemPkgTokenSpaceGuid.PcdTestVar2|0xA5A5|UINT16|0x20000002gUefiOemPkgTokenSpaceGuid.PcdTestVar3|0xA5A5A5A5|UINT32|0x20000003gUefiOemPkgTokenSpaceGuid.PcdTestVar4|0xA5A5A5A5A5A5A5A5|UINT64|0x20000004访问： DEBUG ((EFI_D_ERROR, &quot;[beni]PcdTestVar1: 0x%x.\\n&quot;, PcdGet8 (PcdTestVar1)));DEBUG ((EFI_D_ERROR, &quot;[beni]PcdTestVar2: 0x%x.\\n&quot;, PcdGet16 (PcdTestVar2)));DEBUG ((EFI_D_ERROR, &quot;[beni]PcdTestVar3: 0x%x.\\n&quot;, PcdGet32 (PcdTestVar3)));DEBUG ((EFI_D_ERROR, &quot;[beni]PcdTestVar4: 0x%x.\\n&quot;, PcdGet64 (PcdTestVar4))); Dynamic PCD：前面的三种类型可以认为是静态的PCD，而这里以及之后的是动态的PCD；它的特点是可以在UEFI运行的过程中通过Set宏来修改值；在《edk-ii-build-specification.pdf》中有说明该种类型的PCD必须在DSC中在列一遍，但是实际使用似乎并不是必须的；1234[PcdsDynamic]gUefiOemPkgTokenSpaceGuid.PcdOemVersion|0xABCDDCBA|UINT32|0x40000001DEBUG ((EFI_D_ERROR, &quot;[beni]PcdOemVersion: 0x%x\\n&quot;, PcdGet32 (PcdOemVersion))); DynamicEx PCD：跟Dynamic PCD类似，算是加强版，使用宏PcdGetEx/PcdSetEx来访问变量； PCD变量值的类型： BOOLEAN类型 整型（UINT8，UINT16等） VOID *类型 example : 12[PcdsDynamic] gUefiOemPkgTokenSpaceGuid.PcdOemVersion|0xFFFFFFFF|UINT32|0x40000001 PcdsDynamic PCD类型 PcdOemVersion PCD变量名 0xFFFFFFFF default 值 UINT32 类型 0x40000001 token–&gt; Token是一个32位的整型，在DEC中每个PCD都有一个独一无二的Token PCD 读写值: 1PcdGet32(PcdOemVersion)) 要使用读写函数，需要依赖pcd.inf模块： Pcd.inf模块分为PEI和DXE两个版本，分别放在PEI阶段和DXE阶段的最前面，只有整个模块初始化完成之后，才能够开始正常使用PCD宏来访问Dynamic PCD变量。 以DXE阶段的Pcd.inf模块为例，它主要做了两件事情： 初始化该阶段使用的PCD数据库； 安装各种处理PCD需要的Protocol； 可能用到的protocol: 1234567891011121314151617181920212223242526272829303132333435363738394041////// This service abstracts the ability to set/get Platform Configuration Database (PCD).///typedef struct &#123; PCD_PROTOCOL_SET_SKU SetSku; PCD_PROTOCOL_GET8 Get8; PCD_PROTOCOL_GET16 Get16; PCD_PROTOCOL_GET32 Get32; PCD_PROTOCOL_GET64 Get64; PCD_PROTOCOL_GET_POINTER GetPtr; PCD_PROTOCOL_GET_BOOLEAN GetBool; PCD_PROTOCOL_GET_SIZE GetSize; PCD_PROTOCOL_GET_EX_8 Get8Ex; PCD_PROTOCOL_GET_EX_16 Get16Ex; PCD_PROTOCOL_GET_EX_32 Get32Ex; PCD_PROTOCOL_GET_EX_64 Get64Ex; PCD_PROTOCOL_GET_EX_POINTER GetPtrEx; PCD_PROTOCOL_GET_EX_BOOLEAN GetBoolEx; PCD_PROTOCOL_GET_EX_SIZE GetSizeEx; PCD_PROTOCOL_SET8 Set8; PCD_PROTOCOL_SET16 Set16; PCD_PROTOCOL_SET32 Set32; PCD_PROTOCOL_SET64 Set64; PCD_PROTOCOL_SET_POINTER SetPtr; PCD_PROTOCOL_SET_BOOLEAN SetBool; PCD_PROTOCOL_SET_EX_8 Set8Ex; PCD_PROTOCOL_SET_EX_16 Set16Ex; PCD_PROTOCOL_SET_EX_32 Set32Ex; PCD_PROTOCOL_SET_EX_64 Set64Ex; PCD_PROTOCOL_SET_EX_POINTER SetPtrEx; PCD_PROTOCOL_SET_EX_BOOLEAN SetBoolEx; PCD_PROTOCOL_CALLBACK_ONSET CallbackOnSet; PCD_PROTOCOL_CANCEL_CALLBACK CancelCallback; PCD_PROTOCOL_GET_NEXT_TOKEN GetNextToken; PCD_PROTOCOL_GET_NEXT_TOKENSPACE GetNextTokenSpace;&#125; PCD_PROTOCOL;","categories":[{"name":"uefi","slug":"uefi","permalink":"http://example.com/categories/uefi/"}],"tags":[]},{"title":"UEFI --- env 语法","slug":"uefi/uefi_env","date":"2021-02-22T00:00:00.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"2021/02/22/uefi/uefi_env/","link":"","permalink":"http://example.com/2021/02/22/uefi/uefi_env/","excerpt":"","text":"内容 好像都是定义的宏，要用项目的feature控制类似如下： 12EDK_GLOBAL EMULATIO_XX_ONLY = NOEDK_GLOBAL EMULATIO_XX_GIO_ONLY = YES","categories":[{"name":"uefi","slug":"uefi","permalink":"http://example.com/categories/uefi/"}],"tags":[]},{"title":"UEFI --- dsc 语法","slug":"uefi/uefi_dsc","date":"2021-02-22T00:00:00.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"2021/02/22/uefi/uefi_dsc/","link":"","permalink":"http://example.com/2021/02/22/uefi/uefi_dsc/","excerpt":"","text":"语法例子 变量定义与判断 1234567891011DEFINE SECURE_BOOT_ENABLE = FALSE!if $(SECURE_BOOT_ENABLE) == TRUE PlatformSecureLib|OvmfPkg/Library/PlatformSecureLib/PlatformSecureLib.inf TpmMeasurementLib|SecurityPkg/Library/DxeTpmMeasurementLib/DxeTpmMeasurementLib.inf AuthVariableLib|SecurityPkg/Library/AuthVariableLib/AuthVariableLib.inf!else TpmMeasurementLib|MdeModulePkg/Library/TpmMeasurementLibNull/TpmMeasurementLibNull.inf AuthVariableLib|MdeModulePkg/Library/AuthVariableLibNull/AuthVariableLibNull.inf!endif Section Section的大致格式如下：[oo.xx.zz]。这里oo是必选的，而xx、zz等需要根据oo的值来确定是否存在以及具体是什么内容。下面就介绍这些常用的Section关键字。 12345678910111213141516171819[Defines] PLATFORM_NAME = LearnUefi PLATFORM_GUID = 5a9e7754-d81b-49ea-85ad-69eaa7b1539b PLATFORM_VERSION = 0.1 DSC_SPECIFICATION = 0x00010005 OUTPUT_DIRECTORY = Build/LearnUefiPkg SUPPORTED_ARCHITECTURES = X64 BUILD_TARGETS = NOOPT|DEBUG|RELEASE SKUID_IDENTIFIER = DEFAULT FLASH_DEFINITION = LearnUefiPkg/LearnUefiPkg.fdf # # Defines for default states. These can be changed on the command line. # -D FLAG=VALUE # DEFINE SECURE_BOOT_ENABLE = FALSE DEFINE NETWORK_IP6_ENABLE = FALSE DEFINE HTTP_BOOT_ENABLE = FALSE DEFINE SMM_REQUIRE = FALSE 这个Section用来指定编译选项。EDK可以在Windows、Linux和Mac上编译，所以这里的宏也可以指定不同的系统，且EDK包含很多的语言，所以也可以指定。此外，比较特别的一点是，BIOS包含的模块有不同的类型，不同类型会对应不同的体系架构，比如PEIM需要的是32位的编译，DXE之后需要64位的编译，等等。所以这个Section还有一些变种： 123456[BuildOptions] [BuildOptions.common][BuildOptions.$(ARCH)][BuildOptions.common.CodeBase][BuildOptions.$(ARCH).CodeBase][BuildOptions.$(ARCH).CodeBase.$(MODULE_TYPE)] [LibraryClasses]这个Section定义了所以使用到的库函数。由于库可以使用在不同的阶段和架构，所以它也分为不同的子类，如下所示： 1234567891011121314[LibraryClasses][LibraryClasses.common][LibraryClasses.$(ARCH)][LibraryClasses.common.$(MODULE_TYPE)][LibraryClasses.$(ARCH).$(MODULE_TYPE) ]越精细的范围覆盖越通用的范围[LibraryClasses] PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf[LibraryClasses.common] BaseCryptLib|CryptoPkg/Library/BaseCryptLib/BaseCryptLib.inf[LibraryClasses.common.SEC] TimerLib|OvmfPkg/Library/AcpiTimerLib/BaseRomAcpiTimerLib.inf QemuFwCfgLib|OvmfPkg/Library/QemuFwCfgLib/QemuFwCfgSecLib.inf [PcdsXXX]PCD的Section有不同的种类，对应不同的PCD类型，如下所示： 123456789[PcdsFeatureFlag][PcdsFixedAtBuild][PcdsDynamicDefault][PcdsPatchableInModule][PcdsFeatureFlag] gEfiMdeModulePkgTokenSpaceGuid.PcdHiiOsRuntimeSupport|FALSE gEfiMdeModulePkgTokenSpaceGuid.PcdStatusCodeUseSerial|FALSE gEfiMdeModulePkgTokenSpaceGuid.PcdStatusCodeUseMemory|TRUE [Components]该Section中包含所以需要编译的模块，同样由于模块的不同，这里也会对应不同的变种： 12345678910111213[Components][Components.common][Components.$(ARCH)][Components] OvmfPkg/ResetVector/ResetVector.inf # # SEC Phase modules # OvmfPkg/Sec/SecMain.inf &#123; &lt;LibraryClasses&gt; NULL|MdeModulePkg/Library/LzmaCustomDecompressLib/LzmaCustomDecompressLib.inf &#125;","categories":[{"name":"uefi","slug":"uefi","permalink":"http://example.com/categories/uefi/"}],"tags":[]},{"title":"vim base operation","slug":"vim/vim_base_operation","date":"2021-02-10T00:00:00.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"2021/02/10/vim/vim_base_operation/","link":"","permalink":"http://example.com/2021/02/10/vim/vim_base_operation/","excerpt":"","text":"安装 1sudo apt-getinstall vim// Ubuntu 其他平台，可以自行谷歌。 新手指南 vimtutor// vim 教程上面是史上最简单，最全面的Vim基础教程，至今无人超越。 下面是作者基于上面的归纳： 移动光标 12345678910# hjkl# 2w 向前移动两个单词# 3e 向前移动到第 3 个单词的末尾# 0 移动到行首# $ 当前行的末尾# gg 文件第一行# G 文件最后一行# 行号+G 指定行# &lt;ctrl&gt;+o 跳转回之前的位置# &lt;ctrl&gt;+i 返回跳转之前的位置 退出 123# &lt;esc&gt; 进入正常模式# :q! 不保存退出# :wq 保存后退出 删除 123456# x 删除当前字符# dw 删除至当前单词末尾# de 删除至当前单词末尾，包括当前字符# d$ 删除至当前行尾# dd 删除整行# 2dd 删除两行 修改 1234# i 插入文本# A 当前行末尾添加# r 替换当前字符# o 打开新的一行并进入插入模式 撤销 12# u 撤销# &lt;ctrl&gt;+r 取消撤销 复制粘贴剪切 12345# v 进入可视模式# y 复制# p 粘贴# yy 复制当前行# dd 剪切当前行 状态 1#&lt;ctrl&gt;+g 显示当前行以及文件信息 查找 1234567# / 正向查找（n：继续查找，N：相反方向继续查找）# ？ 逆向查找# % 查找配对的 &#123;，[，(# :set ic 忽略大小写# :set noic 取消忽略大小写# :set hls 匹配项高亮显示# :set is 显示部分匹配 替换 123# :s/old/new 替换该行第一个匹配串# :s/old/new/g 替换全行的匹配串# :%s/old/new/g 替换整个文件的匹配串 折叠 1234# zc 折叠# zC 折叠所有嵌套# zo 展开折叠# zO 展开所有折叠嵌套 执行外部命令 123:!shell 执行外部命令.vimrc.vimrc 是 Vim 的配置文件，需要我们自己创建： Vim12curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim Neovim123curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim其他平台，可以查看 vim-plug[1]。 基本配置 cd Home // 进入 Home 目录touch .vimrc // 配置文件 取消备份12set nobackupset noswapfile 文件编码1setencoding=utf-8 显示行号1setnumber 取消换行1setnowrap 显示光标当前位置1setruler 设置缩进123set cindentset tabstop=2set shiftwidth=2 突出显示当前行1setcursorline 查找123set icset hlsset is 左下角显示当前vim模式1setshowmode 代码折叠12#启动 vim 时关闭折叠代码set nofoldenable 主题123syntax enableset background=darkcolorscheme solarized ◈ altercation/vim-colors-solarized2◈ Anthony25/gnome-terminal-colors-solarized3 插件配置 树形目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445Plug &#x27;scrooloose/nerdtree&#x27;Plug &#x27;jistr/vim-nerdtree-tabs&#x27;Plug &#x27;Xuyuanp/nerdtree-git-plugin&#x27;autocmd vimenter * NERDTreemap &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;let NERDTreeShowHidden=1let g:NERDTreeShowIgnoredStatus = 1let g:nerdtree_tabs_open_on_console_startup=1let g:NERDTreeIndicatorMapCustom = &#123; \\ &quot;Modified&quot; : &quot;✹&quot;, \\ &quot;Staged&quot; : &quot;✚&quot;, \\ &quot;Untracked&quot; : &quot;✭&quot;, \\ &quot;Renamed&quot; : &quot;➜&quot;, \\ &quot;Unmerged&quot; : &quot;═&quot;, \\ &quot;Deleted&quot; : &quot;✖&quot;, \\ &quot;Dirty&quot; : &quot;✗&quot;, \\ &quot;Clean&quot; : &quot;✔︎&quot;, \\ &#x27;Ignored&#x27; : &#x27;☒&#x27;, \\ &quot;Unknown&quot; : &quot;?&quot; \\ &#125;# o 打开关闭文件或目录# e 以文件管理的方式打开选中的目录# t 在标签页中打开# T 在标签页中打开，但光标仍然留在 NERDTree# r 刷新光标所在的目录# R 刷新当前根路径# X 收起所有目录# p 小写，跳转到光标所在的上一级路径# P 大写，跳转到当前根路径# J 到第一个节点# K 到最后一个节点# I 显示隐藏文件# m 显示文件操作菜单# C 将根路径设置为光标所在的目录# u 设置上级目录为根路径# ctrl + w + w 光标自动在左右侧窗口切换# ctrl + w + r 移动当前窗口的布局位置# :tabc 关闭当前的 tab# :tabo 关闭所有其他的 tab# :tabp 前一个 tab# :tabn 后一个 tab# gT 前一个 tab# gt 后一个 tab ◈ scrooloose/nerdtree4◈ vim-nerdtree-tabs5◈ nerdtree-git-plugin6 代码，引号，路径补全123Plug &#x27;Valloric/YouCompleteMe&#x27;Plug &#x27;Raimondi/delimitMate&#x27;Plug &#x27;Shougo/deoplete.nvim&#x27;, &#123; &#x27;do&#x27;: &#x27;:UpdateRemotePlugins&#x27; &#125; ◈ Valloric/YouCompleteMe7◈ Raimondi/delimitMate8◈ Shougo/deoplete.nvim9 语法高亮，检查12345678910111213141516171819Plug &#x27;sheerun/vim-polyglot&#x27;Plug &#x27;w0rp/ale&#x27;let g:ale_linters = &#123;\\ &#x27;javascript&#x27;: [&#x27;eslint&#x27;],\\ &#x27;css&#x27;: [&#x27;stylelint&#x27;],\\&#125;let g:ale_fixers = &#123;\\ &#x27;javascript&#x27;: [&#x27;eslint&#x27;],\\ &#x27;css&#x27;: [&#x27;stylelint&#x27;],\\&#125;let g:ale_fix_on_save = 1let g:ale_sign_column_always = 1let g:ale_sign_error = &#x27;●&#x27;let g:ale_sign_warning = &#x27;▶&#x27;nmap &lt;silent&gt; &lt;C-k&gt; &lt;Plug&gt;(ale_previous_wrap)nmap &lt;silent&gt; &lt;C-j&gt; &lt;Plug&gt;(ale_next_wrap) ◈ w0rp/ale10◈ sheerun/vim-polyglot11 文件，代码搜索12Plug &#x27;rking/ag.vim&#x27;Plug &#x27;kien/ctrlp.vim&#x27; ◈ kien/ctrlp.vim12◈ ggreer/the_silver_searcher13◈ rking/ag.vim14 加强版状态栏1234Plug &#x27;vim-airline/vim-airline&#x27;Plug &#x27;vim-airline/vim-airline-themes&#x27;let g:airline_theme=&#x27;papercolor&#x27; ◈ vim-airline/vim-airline15◈ vim-airline/vim-airline-themes16 代码注释123456789101112131415161718Plug &#x27;scrooloose/nerdcommenter&#x27;# &lt;leader&gt;cc // 注释# &lt;leader&gt;cm 只用一组符号注释# &lt;leader&gt;cA 在行尾添加注释# &lt;leader&gt;c$ /* 注释 */# &lt;leader&gt;cs /* 块注释 */# &lt;leader&gt;cy 注释并复制# &lt;leader&gt;c&lt;space&gt; 注释/取消注释# &lt;leader&gt;ca 切换 // 和 /* */# &lt;leader&gt;cu 取消注释let g:NERDSpaceDelims = 1let g:NERDDefaultAlign = &#x27;left&#x27;let g:NERDCustomDelimiters = &#123; \\ &#x27;javascript&#x27;: &#123; &#x27;left&#x27;: &#x27;//&#x27;, &#x27;leftAlt&#x27;: &#x27;/**&#x27;, &#x27;rightAlt&#x27;: &#x27;*/&#x27; &#125;, \\ &#x27;less&#x27;: &#123; &#x27;left&#x27;: &#x27;/**&#x27;, &#x27;right&#x27;: &#x27;*/&#x27; &#125; \\ &#125; ◈ scrooloose/nerdcommenter17 git12Plug &#x27;airblade/vim-gitgutter&#x27;Plug &#x27;tpope/vim-fugitive&#x27; ◈ airblade/vim-gitgutter18◈ tpope/vim-fugitive19 Markdown12345Plug &#x27;suan/vim-instant-markdown&#x27;let g:instant_markdown_slow = 1let g:instant_markdown_autostart = 0# :InstantMarkdownPreview ◈ suan/vim-instant-markdown20 Emmet12345678Plug &#x27;mattn/emmet-vim&#x27;let g:user_emmet_leader_key=&#x27;&lt;Tab&gt;&#x27;let g:user_emmet_settings = &#123; \\ &#x27;javascript.jsx&#x27; : &#123; \\ &#x27;extends&#x27; : &#x27;jsx&#x27;, \\ &#125;, \\ &#125; ◈ mattn/emmet-vim21 html 51Plug&#x27;othree/html5.vim&#x27; ◈ othree/html5.vim22 css 312345678Plug &#x27;hail2u/vim-css3-syntax&#x27;Plug &#x27;ap/vim-css-color&#x27;augroup VimCSS3Syntax autocmd! autocmd FileType css setlocal iskeyword+=-augroup END ◈ hail2u/vim-css3-syntax23◈ ap/vim-css-color24 JavaScipt123456789101112131415161718Plug &#x27;pangloss/vim-javascript&#x27;let g:javascript_plugin_jsdoc = 1let g:javascript_plugin_ngdoc = 1let g:javascript_plugin_flow = 1set foldmethod=syntaxlet g:javascript_conceal_function = &quot;ƒ&quot;let g:javascript_conceal_null = &quot;ø&quot;let g:javascript_conceal_this = &quot;@&quot;let g:javascript_conceal_return = &quot;⇚&quot;let g:javascript_conceal_undefined = &quot;¿&quot;let g:javascript_conceal_NaN = &quot;ℕ&quot;let g:javascript_conceal_prototype = &quot;¶&quot;let g:javascript_conceal_static = &quot;•&quot;let g:javascript_conceal_super = &quot;Ω&quot;let g:javascript_conceal_arrow_function = &quot;⇒&quot;let g:javascript_conceal_noarg_arrow_function = &quot; &quot;let g:javascript_conceal_underscore_arrow_function = &quot; &quot;set conceallevel=1 ◈ pangloss/vim-javascript25（注：上述脚本中存在特殊字符，有的情况下显示不正确，请直接用上述链接的内容。） React12Plug &#x27;mxw/vim-jsx&#x27;let g:jsx_ext_required = 0 ◈ mxw/vim-jsx26 Prettier12345678Plug &#x27;prettier/vim-prettier&#x27;, &#123; \\ &#x27;do&#x27;: &#x27;yarn install&#x27;, \\ &#x27;for&#x27;: [&#x27;javascript&#x27;, &#x27;typescript&#x27;, &#x27;css&#x27;, &#x27;less&#x27;, &#x27;scss&#x27;, &#x27;json&#x27;, &#x27;graphql&#x27;] &#125;let g:prettier#config#bracket_spacing = &#x27;true&#x27;let g:prettier#config#jsx_bracket_same_line = &#x27;false&#x27;let g:prettier#autoformat = 0autocmd BufWritePre *.js,*.jsx,*.mjs,*.ts,*.tsx,*.css,*.less,*.scss,*.json,*.graphql PrettierAsync# :Prettier ◈ prettier/vim-prettier27 总结最后，呈上参考配置 .vimrc28，如果关于 vim 有更好的 idea，欢迎在评论中交流。 My vimrc config 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849set nuset ts=2set hlsearch set etset expandtabnoremap &lt;A-up&gt; :call feedkeys( line(&#x27;.&#x27;)==1 ? &#x27;&#x27; : &#x27;ddkP&#x27; )&lt;CR&gt;noremap &lt;A-down&gt; ddp&quot; tags 设置set tags=tags; set autochdirif has(&quot;cscope&quot;) set csprg=/usr/bin/cscope &quot;指定用来执行 cscope 的命令 set csto=1 &quot;先搜索tags标签文件,再搜索cscope数据库 set cst &quot;使用|:cstag|(:cs find g),而不是缺省的:tag set nocsverb &quot;不显示添加数据库是否成功 &quot; add any database in current directory if filereadable(&quot;cscope.out&quot;) cs add cscope.out &quot;添加cscope数据库 endif &quot;显示添加成功与否 set csverbendif:set cscopequickfix=s-,c-,d-,i-,t-,e-nmap &lt;C-\\&gt;s :cs find s &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-\\&gt;g :cs find g &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-\\&gt;c :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-\\&gt;t :cs find t &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-\\&gt;e :cs find e &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-\\&gt;f :cs find f &lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-\\&gt;i :cs find i ^&lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;$&lt;CR&gt;nmap &lt;C-\\&gt;d :cs find d &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;&quot; quick exit nmap &lt;ESC&gt; :wqsyntax onset nocp","categories":[{"name":"vim","slug":"vim","permalink":"http://example.com/categories/vim/"}],"tags":[]},{"title":"Linux Crash Tool","slug":"tool/linux_crash","date":"2021-02-09T00:00:00.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"2021/02/09/tool/linux_crash/","link":"","permalink":"http://example.com/2021/02/09/tool/linux_crash/","excerpt":"","text":"下载","categories":[{"name":"tools","slug":"tools","permalink":"http://example.com/categories/tools/"}],"tags":[]},{"title":"bios issue fiexd","slug":"interview/bios_related","date":"2021-02-09T00:00:00.000Z","updated":"2021-03-09T10:47:23.651Z","comments":true,"path":"2021/02/09/interview/bios_related/","link":"","permalink":"http://example.com/2021/02/09/interview/bios_related/","excerpt":"","text":"1. softfuse struck A5EF1. softfuse struck A5EF","categories":[{"name":"interview","slug":"interview","permalink":"http://example.com/categories/interview/"}],"tags":[]},{"title":"interview","slug":"interview/interview","date":"2021-02-09T00:00:00.000Z","updated":"2021-03-09T10:47:23.651Z","comments":true,"path":"2021/02/09/interview/interview/","link":"","permalink":"http://example.com/2021/02/09/interview/interview/","excerpt":"","text":"中断 中断分为上半部和下半部，上半部关中断；下半部开中断，处理可以延迟的事情。下半部有workqueue/softirq/tasklet三种方式顶半部，硬件作答，快速响应底半部，延时执行 local_irq_disable和disable_irq区别： workquence 工作队列允许重新调度甚至是睡眠,workqueue_struct d-&gt;workINIT_WORK(&amp;d-&gt;work, work_task);schedule_work(&amp;d-&gt;work); 指定cpudestroy_workqueue() softirq 无法sleep静态定义软中断数组softirq_vec, 存放各自的中断处理函数softirq_action 每个CPU都有一个这样的数组，谁发起，谁执行 内核限制32个， 如mac_tx, mac_rx, tasklet, 定时器使用： void open_softirq(int nr, void (*action)(struct softirq_action *)) 添加中断回调函数。 raise_softirq() 触发软中断 ，就是在pre-cpu变量__softirq_pending上置位。然后local_softirq_pending() 检测那些pending， 执行invoke_softirq() 如果多个softirq pending, 按数组顺序执行。 网络收发软中断有超时机制，和次数限制。 tasklet 演示40ms 无法睡眠pre-cpu 维护一tasklet list , tasklet一旦挂入一个cpu的tasklet表，就只会在该cpu上运行，哪怕被重新调度使用： DECLARE_TASKLET(&amp;port-&gt;tasklet, callback, data) tasklet_schedule(&amp;port-&gt;tasklet); tasklet_kill(&amp;port-&gt;tasklet); tasklet_disable(&amp;port-&gt;tasklet);只用于disable tasklet , 而local_bh_disable/enable 是disable bh 操作 softirq/tasklet. tasklet_enable(&amp;port-&gt;tasklet); runqueue linux 就绪队列struct runqueue，每个CPU都有一个执行队列，队列中以work的形式执行每个任务。 进程 进程切换，有能力挂起正在CPU上执行的进程，和恢复执行。进程调度由schedule()函数实现 complete 进程同步机制 struct completion { unsigned int done;/用于同步的原子量/ 类似信号量，等待一个减1 wait_queue_head_t wait;/等待事件队列/};用法： 这个变量可以静态地声明和初始化： DECLARE_COMPLETION(my_comp); 或者动态初始化： struct completion my_comp; init_completion(&amp;my_comp); wait_for_completion(struct completion *comp);等待其他事件完成 ， 将当前进程放入wait quence尾，sch超时唤醒后，循环检测done是否可用 其他事件完成后调用complete(struct completion *comp); 唤醒等待该事件的所在进程 notify 机制， 模块之间通信 struct notifier_block{ int (*notifier_call)(struct notifier_block *self, unsigned long, void *); struct notifier_block *next; int priority;};notifier_chain_registernotifier_call_chain devicefs DEVICE_ATTR 需要绑定设备struct device_attribute { struct attribute attr; ssize_t (*show)(struct device *dev, struct device_attribute *attr,char *buf); ssize_t (*store)(struct device *dev, struct device_attribute *attr,const char *buf, size_t count);};DEVICE_ATTR 实现一些这样的设备属性结构sysfs_create_file(&amp;mydevice-&gt;kobj, &amp;dev_attr_mydevice.attr); 绑定设备与设备属性 debugfs 无需绑定设备，mount debugfs 之后就可以在该目录下找到我们的节点debugfs_create_dir(const char *name, struct dentry *parent);debugfs_create_file(“stats”, S_IRUGO | S_IWUSR, client-&gt;debugfs,client, &amp;debugfs_stats_ops); 绑定文件和函数操作集合 Cmake mafile工程的构建工具 简单语法： include_directories (“${PROJECT_SOURCE_DIR}/MathFunctions”) 添加include add_subdirectory (MathFunctions) 添加子目录 add_executable (Tutorial tutorial.cxx) 定义一个可执行文件，以及依赖的源文件 target_link_libraries (Tutorial MathFunctions) 链接库 makefile $@ 表示目标文件$^ 表示所有的依赖文件$&lt; 表示第一个依赖文件$? 表示比目标还要新的依赖文件列表 原子操作 锁的使用： spinlock: 死等，或者挂起当前进程 一次只有一个thread获取锁 因为可以睡眠，所以可以在BH中使用。使用： spin_lock 关闭内核抢占，也就是说同时只能一个进程获取这个锁，不关闭的，其他的进程抢占，抢占之后发现需要之前的进程解锁才能继续执行，就会导致死锁。 spin_lock_bh spin_lock_softirq 加了这把锁，本地软中断会被禁用。 使用场景： 比如配合tasklet，害怕被软中断sch，又请求锁住的资源，造成死锁。 spin_lock_irq 加了这把锁，本地软中断会被禁用。本地hard irq会被禁用。 spin_lock_irqsave 禁用本地hard irq ， 但是会保存中断状态，配合spin_unlock_irqrestore 进入退出，还原中断状态。 spin_lock_nested 为了配合lockdep 机制，防止误报重复上锁的 互斥锁mutex， 锁住线程共享资源 pthread_mutex_lock 无法获取该所示，进入阻塞（睡眠，这些睡眠的线程会排队访问互斥量），pthread_mutex_trylock 就不会阻塞，直接返回ebusy 读写锁rwlock pthread_rwlock_rdlock(pthread_rwlock_t *rwpt);pthread_rwlock_wrlock(pthread_rwlock_t *rwpt);pthread_rwlock_unlock(pthread_rwlock_t *rwpt); 死锁的例子 2个线程持有2把锁，交叉互锁，出现死锁。 进程空间 进程为什么是4G寻址空间， 一个指针是4字节 32位，寻址能力是2的32次方，是4G.32位linux , 一个进程空间4G，内核占1G，用户留3G，一个线程默认8M(但是因为还要包括 栈区，txt,data， heap 所以实际是大概6M)，所以最多380个左右线程进程栈16K.虚拟空间的3G还要分区： ①栈空间：特点是由系统管理，先进后出，里面放了局部变量、函数形参、自动变量。 ②堆空间：特点是由用户管理，先进后出，我们可以用malloc、ralloc、calloc来分配空间。 alloc(sizeof(int)); 物理连续内存 vmalloc属性：可能睡眠、虚拟地址连续、物理地址不连续、size对齐到页；所以不适合小内存分配，开销较大。 realloc(p, SIZE * 2); 为已经分配空间的指针重新分配空间。 如果新的空间小于旧的空间，则指针不变， 如果大于， 则申请更大空间，然后拷贝原来的内容， 清空就的指针空间。 calloc(SIZE, sizeof(int)); 和malloc 一样，但是会全部初始化为0,不需要memset. ③数据段：数据段里面又分三块，第一块是bss，保存未初始化的全局变量；第二块是rodata，保存了常量；第三块 是.data（静态数据区）保存了初始化的全局变量还有static修饰的变量。 ④代码段：存放了源代码。 kernel/userspace 空间 kernel 空间分区userspace 空间分区 arm 终端流程： 中断流程， A系列不支持中断嵌套 M系列支持 进入中断 保存CPSR到对应cpu的SPSR_mode 关中断 切换到异常状态 保存PC到LR 设置PC到中断向量表中的对应处理函数地址中 恢复中断 恢复 SPSR_mode 到 CPSR 恢复 lr_mode 到 PC 恢复普通寄存器：R0-R7，操作sp将栈中将数据恢复。 devmem 访问dts定义的内存范围内的外设寄存器访问，操作的是物理寄存器 物理内存，虚拟内存如何组织映射。 虚拟地址空间比可用的物理内存大很多，因此只有最常用的部分才与物理页帧关联这不是问题，因为大多数程序只占用实际可用内存的一小部分 野指针 指针在被定义的时候，如果程序不对其进行初始化的话，它会随机指向一个区域，不能判断是否为NULL。 strcpy strcmp strlen 排序算法有哪些 冒泡排序选择排序插入排序希尔排序归并排序 迭代法 递归法快速排序 迭代法 递归法 c 函数型参处于那个内存空间 （可以尝试从汇编调用函数开始理解） 形参的传递在arm架构中，如果你的参数少于三个，则是通过R0或R0、R1或R0、R1、R2传递过去的，如果多余三个则是多出来的是通过堆栈传递的 实参是放栈上的 行参是一个占位符，它没有数据 发生函数调用时，实参的值会传递给形参 形参和实参虽然可以同名，但它们之间是相互独立的，互不影响，因为实参在函数外部有效，而形参在函数内部有效。 函数返回值将会又主函数开辟一个临时的新的内存空间来保存 如下例子：x86平台上，前3个参数传递给了 core 寄存器，就是arm中的R0/R1/R2通用寄存器，后面的参数压栈了 2分法查找 AT 命令 lcd 原理 frambuffer 机制 http ftp TCP/IP 协议 spsr cpsr[31:28/条件标志，执行汇编的算数运算时，表示运算结果]NZCV[27:8] 保留[7：5 | 7:I/irq使能 6:F/快中断 5：T状态位，arm/thumb] t=1 强制进入未定义指令中断[4:0] 模式 物理/虚拟地址映射 32位linux总地址4G 一级页表页大小4K, 共4G/4k个页，每1M个页组成1个页目录，1M个页目录是一个固定入口地址， 存在CR3 中。二级页表存储1M页目录 页目录地址-&gt; CR3寄存器一个虚拟地址的组成： DIRECTORY [22：31] 可表示1024个页目录（PGD） TABLE[12：21] 可表示1024个页表（PTE) OFFSET[22：31] 可表示4096个物理内存 copy_to_user/copy_form_user 虚拟内存地址对应的物理内存与内核虚拟内存地址对应的物理内存 mmap 用户空间虚拟地址与物理地址的map 目标是在用户空间访问硬件，所有可以省去映射到kernel虚拟空间这一步。 ioremap 内核空间虚拟地址与物理地址的map IPC 机制 信号 信号量 管道 消息队列 itouch hexgon SDK running time logger , fastRPC TDDI , 时序同步 屏幕基本 一个像素8bit RGB信号发生时间 vsync 到一帧的最后一个像素 -&gt; 发出VBP(帧后的同步时间) -&gt; hsync 行同步信号 -&gt; HBP行后同步时间 -&gt; 一行像素 -&gt; HFP行前同步信号 -&gt; VFP帧前同步信号 android 版本更新时间节点 霍尔器件的驱动移植 霍尔器件是磁感应器件，上电后，当检测到磁性物体靠近，中断脚就会产生一个高脉冲。1，在DWS文件中配置上电，中断等管脚，然后在DTS中编写基础配置；2，编写一个字符驱动，内含中断注册，检测，并向上层提供调用接口。 improveTouch 1，高通android参考机外设improveTouch研发，区别于传统的第三方touch， improveTouch核心算法主要放在dsp中运算，通过userspace nativea app控制，kernel driver向input子系统转发触摸事件。2，算法组维护adsp中的hal，算法，系统组负责平台的移植 userspace/kernel的代码维护。3，我主要是编写 dts/driver 的代码，通过pinctrl/set_regulator等kernel api 管理硬件资源,维护usersapce的代码，开发版本的整合，wiki文档的更新。解决内部测试团队发现的bug。4，其他芯片平台有过secureTouch的开发例子,对于新的touch驱动做一个移植，跑通。主要是在kernel 和trustzone子系统中添加code。 crash 工具的使用，死机问题分析 mem 我理解是DDR devmem 访问dts定义的内存范围内的外设寄存器访问，操作的是物理寄存器 http ftp TCP/IP 协议 触摸屏突然不亮检查流程 上电，reset电路，总线通信。getevent检查多点触摸协议报点是否有，是否符合报点规范。 stack 栈由高到低生长 kernel栈16K uart 子系统 网络 子系统 misc驱动 input系统 多点触摸协议 手势检测 M7 i2c 发出从地址后，没有ack 从地址不对？ 轮寻一定范围的地址，查看是否有ack.M7的时钟 200/300/400Mi2c 低中高时钟 100K/ Rtos 与 linux的区别 主要区别在于实时性 sn3193 类似芯片 关键参数流程 bl0,bl1,bl2,bl3 ( sanxin 4412 )的区别，与联系 为什么需要bootloader 存在，没有bootloader 当然可以启动系统。有bootloader的好处，系统升级。只要将对应的image 放在某个地址，重启就可以了。不需要接烧写器烧写。 bl0, blx 就类似于不同阶段，不同功能的bootloader, 分多个也是为了方便升级替换 （ 典型应用 : fastboot flash bootloader xxx.bin ） BL0：三星公司固化到SOC内部的ROM（iROM），里面主要是尽可能只做uboot加载，尽可能消除其他的影响（关闭WDT、禁用IRQ、关闭cache等等），接下来就是从外设拷贝加载BL1BL1：没什么特殊功能，特点就是经过加密的，而且BL1由三星公司提供好的，完成对BL2的加载到iRAM运行。要想在开发板上移植运行后续的代码，通过签名的方式实现软件和硬件合法性的匹配BL2：由平台研发人员编写，根据SOC外内存硬件不同、工作频率不同，进行初始化设置，完成后续代码加载到初始化后的内存中运行","categories":[{"name":"interview","slug":"interview","permalink":"http://example.com/categories/interview/"}],"tags":[]},{"title":"c binary 相关工具","slug":"tool/c_binary","date":"2021-02-08T00:00:00.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"2021/02/08/tool/c_binary/","link":"","permalink":"http://example.com/2021/02/08/tool/c_binary/","excerpt":"","text":"strings 列出bin文件中的字符串 12345678910111213141516171819strings a.out /lib64/ld-linux-x86-64.so.2libc.so.6puts__cxa_finalizestrcmp__libc_start_mainGLIBC_2.2.5_ITM_deregisterTMCloneTable__gmon_start___ITM_registerTMCloneTableu+UH[]A\\A]A^A_cheking passwd!ok you got meWRONG !Usage: &lt;key&gt;:*3$&quot; 2进制转16进制 vim 中 ：%！xxd 退回二进制： ：%！xxd -r bash shell: xxd a.out &gt; 16.txt file 12345678~~~---### readelf ---查看程序段信息, [参考文档](https://blog.csdn.net/yfldyxl/article/details/81566279)~~~bash readelf -S a.out # -S(section headers),sections addr2line 1","categories":[{"name":"tools","slug":"tools","permalink":"http://example.com/categories/tools/"}],"tags":[]},{"title":"vim plug","slug":"tool/vim","date":"2021-02-08T00:00:00.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"2021/02/08/tool/vim/","link":"","permalink":"http://example.com/2021/02/08/tool/vim/","excerpt":"","text":"安装vim-plug 12vim : curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vimneovim : curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 配置 vim-plug 修改 ~/.vimrc 123call plug#begin(&#x27;~/.vim/plugged&#x27;)Plug &#x27;itchyny/lightline.vim&#x27;call plug#end() 插件操作 12345678# 导入插件:PlugInstall# 更新插件:PlugUpdate# 清理插件:PlugClean 常用插件 12# 目录树Plug &#x27;scrooloose/nerdtree&#x27;, &#123; &#x27;on&#x27;: &#x27;NERDTreeToggle&#x27; &#125; 配置实现的插件 换行 ALT + 上下 实现vscode类似的换行效果 12noremap &lt;A-up&gt; :call feedkeys( line(&#x27;.&#x27;)==1 ? &#x27;&#x27; : &#x27;ddkP&#x27; )&lt;CR&gt;noremap &lt;A-down&gt; ddp","categories":[{"name":"tools","slug":"tools","permalink":"http://example.com/categories/tools/"}],"tags":[]},{"title":"Youtube-dl youtube视频批量下载","slug":"tool/youtuber_dll","date":"2021-02-08T00:00:00.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"2021/02/08/tool/youtuber_dll/","link":"","permalink":"http://example.com/2021/02/08/tool/youtuber_dll/","excerpt":"","text":"what is Youtube-dl ？ Youtube-dl 是一个自由开源的命令行视频下载工具，可以用来从 Youtube 等类似的网站上下载视频，目前它支持的网站除了 Youtube 还有 Facebook、Dailymotion、Google Video、Yahoo 等等。它构架于 pygtk 之上，需要 Python 的支持来运行。它支持很多操作系统，包括 Windows、Mac 以及 Unix。Youtube-dl 还有断点续传、下载整个频道或者整个播放清单中的视频、添加自定义的标题、代理等等其他功能。 12345sudo apt-get update -ysudo apt-get upgrade -ysudo apt-get install curl -ycurl -L https://yt-dl.org/latest/youtube-dl -o /usr/bin/youtube-dlchmod 755 /usr/bin/youtube-dl 12345678910111213141516171819202122232425262728# 显示所有视频格式youtube-dl -F https://www.youtube.com/watch?v=j_JgXJ-apXs [info] Available formats for j_JgXJ-apXs:format code extension resolution note139 m4a audio only DASH audio 56k , m4a_dash container, mp4a.40.5@ 48k (22050Hz), 756.44KiB249 webm audio only DASH audio 56k , opus @ 50k, 724.28KiB250 webm audio only DASH audio 69k , opus @ 70k, 902.75KiB171 webm audio only DASH audio 110k , vorbis@128k, 1.32MiB251 webm audio only DASH audio 122k , opus @160k, 1.57MiB140 m4a audio only DASH audio 146k , m4a_dash container, mp4a.40.2@128k (44100Hz), 1.97MiB278 webm 256x144 144p 97k , webm container, vp9, 24fps, video only, 1.33MiB160 mp4 256x144 DASH video 102k , avc1.4d400c, 24fps, video only, 731.53KiB133 mp4 426x240 DASH video 174k , avc1.4d4015, 24fps, video only, 1.36MiB242 webm 426x240 240p 221k , vp9, 24fps, video only, 1.74MiB134 mp4 640x360 DASH video 369k , avc1.4d401e, 24fps, video only, 2.90MiB243 webm 640x360 360p 500k , vp9, 24fps, video only, 4.15MiB135 mp4 854x480 DASH video 746k , avc1.4d401e, 24fps, video only, 6.11MiB244 webm 854x480 480p 844k , vp9, 24fps, video only, 7.27MiB247 webm 1280x720 720p 1155k , vp9, 24fps, video only, 9.21MiB136 mp4 1280x720 DASH video 1300k , avc1.4d401f, 24fps, video only, 9.66MiB248 webm 1920x1080 1080p 1732k , vp9, 24fps, video only, 14.24MiB137 mp4 1920x1080 DASH video 2217k , avc1.640028, 24fps, video only, 15.28MiB17 3gp 176x144 small , mp4v.20.3, mp4a.40.2@ 24k36 3gp 320x180 small , mp4v.20.3, mp4a.40.243 webm 640x360 medium , vp8.0, vorbis@128k18 mp4 640x360 medium , avc1.42001E, mp4a.40.2@ 96k22 mp4 1280x720 hd720 , avc1.64001F, mp4a.40.2@192k (best) 然后使用 -f 指定你想要下载的格式，如下所示： 12345678youtube-dl -f 18 https://www.youtube.com/watch?v=j_JgXJ-apXs[youtube] j_JgXJ-apXs: Downloading webpage[youtube] j_JgXJ-apXs: Downloading video info webpage[youtube] j_JgXJ-apXs: Extracting video information[youtube] j_JgXJ-apXs: Downloading MPD manifest[download] Destination: B.A. PASS 2 Trailer no 2 _ Filmybox-j_JgXJ-apXs.mp4[download] 100% of 6.90MiB in 00:47 下载音频1youtube-dl https://www.youtube.com/watch?v=j_JgXJ-apXs -x --audio-format mp3 下载视频1youtube-dl -citw https://www.youtube.com/channel/UCatfiM69M9ZnNhOzy0jZ41A 指定代理1youtube-dl --proxy http://proxy-ip:port https://www.youtube.com/watch?v=j_JgXJ-apXs youtube-list若想一条命令下载多个 Youtube 视频，那么首先把所有要下载的 Youtube 视频 URL 存在一个文件中（假设这个文件叫 youtube-list.txt），然后运行下面命令： 1youtube-dl -a youtube-list.txt","categories":[{"name":"tools","slug":"tools","permalink":"http://example.com/categories/tools/"}],"tags":[]},{"title":"cscope 安装 配置 使用","slug":"tool/cscope","date":"2021-02-08T00:00:00.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"2021/02/08/tool/cscope/","link":"","permalink":"http://example.com/2021/02/08/tool/cscope/","excerpt":"","text":"安装 1sudo apt install cscope 配置 ~/.vimrc 中添加如下配置 12345678910111213141516171819202122232425262728293031323334&quot; tags 设置set tags=tags; set autochdirif has(&quot;cscope&quot;) set csprg=/usr/bin/cscope &quot;指定用来执行 cscope 的命令 set csto=1 &quot;先搜索tags标签文件,再搜索cscope数据库 set cst &quot;使用|:cstag|(:cs find g),而不是缺省的:tag set nocsverb &quot;不显示添加数据库是否成功 &quot; add any database in current directory if filereadable(&quot;cscope.out&quot;) cs add cscope.out &quot;添加cscope数据库 endif &quot;显示添加成功与否 set csverbendif:set cscopequickfix=s-,c-,d-,i-,t-,e-nmap &lt;C-\\&gt;s :cs find s &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-\\&gt;g :cs find g &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;# 查找哪里调用了当前的函数nmap &lt;C-\\&gt;c :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-\\&gt;t :cs find t &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;# 查找所有符号nmap &lt;C-\\&gt;e :cs find e &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-\\&gt;f :cs find f &lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-\\&gt;i :cs find i ^&lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;$&lt;CR&gt;nmap &lt;C-\\&gt;d :cs find d &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt; 建立索引 建立脚本，执行生成tag, cscope符号表 12345#!/bin/shfind `pwd` -name &quot;*.[ch]&quot; -o -name &quot;*.cpp&quot; &gt; cscope.files cscope -bRkq -i cscope.files ctags -R cscope 使用 快捷键，上面配置中已经配置了。 123456789101112131415161718192021222324252627282930cscope --helpUsage: cscope [-bcCdehklLqRTuUvV] [-f file] [-F file] [-i file] [-I dir] [-s dir] [-p number] [-P path] [-[0-8] pattern] [source files]-b Build the cross-reference only.-C Ignore letter case when searching.-c Use only ASCII characters in the cross-ref file (don&#x27;t compress).-d Do not update the cross-reference.-e Suppress the &lt;Ctrl&gt;-e command prompt between files.-F symfile Read symbol reference lines from symfile.-f reffile Use reffile as cross-ref file name instead of cscope.out.-h This help screen.-I incdir Look in incdir for any #include files.-i namefile Browse through files listed in namefile, instead of cscope.files-k Kernel Mode - don&#x27;t use /usr/include for #include files.-L Do a single search with line-oriented output.-l Line-oriented interface.-num pattern Go to input field num (counting from 0) and find pattern.-P path Prepend path to relative file names in pre-built cross-ref file.-p n Display the last n file path components.-q Build an inverted index for quick symbol searching.-R Recurse directories for files.-s dir Look in dir for additional source files.-T Use only the first eight characters to match against C symbols.-U Check file time stamps.-u Unconditionally build the cross-reference file.-v Be more verbose in line mode.-V Print the version number.Please see the manpage for more information.","categories":[{"name":"tools","slug":"tools","permalink":"http://example.com/categories/tools/"}],"tags":[]},{"title":"linux 上截图工具","slug":"tool/Linux_screencut","date":"2021-02-08T00:00:00.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"2021/02/08/tool/Linux_screencut/","link":"","permalink":"http://example.com/2021/02/08/tool/Linux_screencut/","excerpt":"","text":"","categories":[{"name":"tools","slug":"tools","permalink":"http://example.com/categories/tools/"}],"tags":[]},{"title":"hack binary example","slug":"liveoverflow/hack_binary_example","date":"2021-02-07T00:00:00.000Z","updated":"2021-03-09T10:47:23.651Z","comments":true,"path":"2021/02/07/liveoverflow/hack_binary_example/","link":"","permalink":"http://example.com/2021/02/07/liveoverflow/hack_binary_example/","excerpt":"","text":"目的 通过修改bin文件，跳过字符串匹配，密码检查。 代码 123456789101112131415#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc,char* argv[])&#123; if (argc == 2)&#123; printf(&quot;cheking passwd!\\n&quot;); if (strcmp(&quot;pwd&quot;,argv[1]) == 0)&#123; printf(&quot;ok you got me\\n&quot;); &#125;else printf(&quot;WRONG !\\n&quot;); &#125;else printf(&quot;Usage: &lt;key&gt;\\n&quot;); return ; &#125; 带参数打开gdb 1gdb --args ./a.out pwd gdb 检查 我们通过gdb单步，到strcmp后一步,打开汇编 1234567891011121314151617181920212223242526272829303132333435 (gdb) n 10 printf(&quot;WRONG !\\n&quot;); (gdb) disassemble Dump of assembler code for function main: 0x0000555555555169 &lt;+0&gt;: endbr64 0x000055555555516d &lt;+4&gt;: push %rbp 0x000055555555516e &lt;+5&gt;: mov %rsp,%rbp 0x0000555555555171 &lt;+8&gt;: sub $0x10,%rsp 0x0000555555555175 &lt;+12&gt;: mov %edi,-0x4(%rbp) 0x0000555555555178 &lt;+15&gt;: mov %rsi,-0x10(%rbp) 0x000055555555517c &lt;+19&gt;: cmpl $0x2,-0x4(%rbp) 0x0000555555555180 &lt;+23&gt;: jne 0x5555555551c8 &lt;main+95&gt; 0x0000555555555182 &lt;+25&gt;: lea 0xe7b(%rip),%rdi # 0x555555556004 0x0000555555555189 &lt;+32&gt;: callq 0x555555555060 &lt;puts@plt&gt; 0x000055555555518e &lt;+37&gt;: mov -0x10(%rbp),%rax 0x0000555555555192 &lt;+41&gt;: add $0x8,%rax 0x0000555555555196 &lt;+45&gt;: mov (%rax),%rax 0x0000555555555199 &lt;+48&gt;: mov %rax,%rsi 0x000055555555519c &lt;+51&gt;: lea 0xe71(%rip),%rdi # 0x555555556014 0x00005555555551a3 &lt;+58&gt;: callq 0x555555555070 &lt;strcmp@plt&gt; 0x00005555555551a8 &lt;+63&gt;: test %eax,%eax 0x00005555555551aa &lt;+65&gt;: jne 0x5555555551ba &lt;main+81&gt; 0x00005555555551ac &lt;+67&gt;: lea 0xe65(%rip),%rdi # 0x555555556018 0x00005555555551b3 &lt;+74&gt;: callq 0x555555555060 &lt;puts@plt&gt; 0x00005555555551b8 &lt;+79&gt;: jmp 0x5555555551d4 &lt;main+107&gt;=&gt; 0x00005555555551ba &lt;+81&gt;: lea 0xe65(%rip),%rdi # 0x555555556026 0x00005555555551c1 &lt;+88&gt;: callq 0x555555555060 &lt;puts@plt&gt; 0x00005555555551c6 &lt;+93&gt;: jmp 0x5555555551d4 &lt;main+107&gt; 0x00005555555551c8 &lt;+95&gt;: lea 0xe5f(%rip),%rdi # 0x55555555602e 0x00005555555551cf &lt;+102&gt;: callq 0x555555555060 &lt;puts@plt&gt; 0x00005555555551d4 &lt;+107&gt;: nop 0x00005555555551d5 &lt;+108&gt;: nop 0x00005555555551d6 &lt;+109&gt;: leaveq 0x00005555555551d7 &lt;+110&gt;: retq End of assembler dump. 可以看到 strcmp 后，有一句：test %eax,%eax ，意思是判断eax 是不是0， 并将状态保存到某个寄存器中，后面肯定也会根据状态判断strcmp返回是不是0 12345(gdb) x/8b 0x00005555555551aa0x5555555551aa &lt;main+65&gt;: 117 14 72 -115 61 101 14 0(gdb) x/8x 0x00005555555551aa0x5555555551aa &lt;main+65&gt;: 0x75 0x0e 0x48 0x8d 0x3d 0x65 0x0e 0x00(gdb) test 后就是跳转命令， jne, 查看intel 架构的手册，他就是根据 0x75 来判断是不是相等的，类似ARM中的 cpsv标志位. 120x75 不等0x74 相等 所以目标就是将0x75更换为0x74,通过上下文的数字确定位置。0x75 0x0e 0x48 0x8d 0x3d 修改16进制文件 vim 中，执行：%！xxd 可以将二进制转换为十六进制修改。 ：%！xxd -r 返回二进制， 保存 1234567891011121314151617181900001120: f30f 1efa 803d e52e 0000 0075 2b55 4883 .....=.....u+UH.00001130: 3dc2 2e00 0000 4889 e574 0c48 8b3d c62e =.....H..t.H.=..00001140: 0000 e809 ffff ffe8 64ff ffff c605 bd2e ........d.......00001150: 0000 015d c30f 1f00 c30f 1f80 0000 0000 ...]............00001160: f30f 1efa e977 ffff fff3 0f1e fa55 4889 .....w.......UH.00001170: e548 83ec 1089 7dfc 4889 75f0 837d fc02 .H....&#125;.H.u..&#125;..00001180: 7546 488d 3d7b 0e00 00e8 d2fe ffff 488b uFH.=&#123;........H.00001190: 45f0 4883 c008 488b 0048 89c6 488d 3d71 E.H...H..H..H.=q000011a0: 0e00 00e8 c8fe ffff 85c0 750e 488d 3d65 ..........u.H.=e000011b0: 0e00 00e8 a8fe ffff eb1a 488d 3d65 0e00 ..........H.=e..000011c0: 00e8 9afe ffff eb0c 488d 3d5f 0e00 00e8 ........H.=_....000011d0: 8cfe ffff 9090 c9c3 0f1f 8400 0000 0000 ................000011e0: f30f 1efa 4157 4c8d 3dc3 2b00 0041 5649 ....AWL.=.+..AVI000011f0: 89d6 4155 4989 f541 5441 89fc 5548 8d2d ..AUI..ATA..UH.-00001200: b42b 0000 534c 29fd 4883 ec08 e8ef fdff .+..SL).H.......00001210: ff48 c1fd 0374 1f31 db0f 1f80 0000 0000 .H...t.1........00001220: 4c89 f24c 89ee 4489 e741 ff14 df48 83c3 L..L..D..A...H..00001230: 0148 39dd 75ea 4883 c408 5b5d 415c 415d .H9.u.H...[]A\\A]00001240: 415e 415f c366 662e 0f1f 8400 0000 0000 A^A_.ff......... 效果 123456789.&#x2F;a.out fawecheking passwd!WRONG !vim a.out .&#x2F;a.out fawecheking passwd!ok you got me binaryninga 有一些GUI工具可以很简单的完成这些步骤，类似的有 binaryninga, 其他的可以在liveoverflow的节目查询蓝色的表示true分支，红色的flase分支，我们只要屏蔽掉检查的分支，直接过去就可以了","categories":[{"name":"liveoverflow","slug":"liveoverflow","permalink":"http://example.com/categories/liveoverflow/"}],"tags":[]},{"title":"git 常用命令列表","slug":"git/05_git_normal_cmd","date":"2021-02-07T00:00:00.000Z","updated":"2021-03-09T10:47:23.651Z","comments":true,"path":"2021/02/07/git/05_git_normal_cmd/","link":"","permalink":"http://example.com/2021/02/07/git/05_git_normal_cmd/","excerpt":"","text":"git config 配置 Git 的相关参数。 Git 一共有3个配置文件： 仓库级的配置文件：在仓库的 .git/.gitconfig，该配置文件只对所在的仓库有效。 全局配置文件：Mac 系统在 ~/.gitconfig，Windows 系统在 C:\\Users&lt;用户名&gt;.gitconfig。 系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 /usr/local/git）的 etc 文件夹中的 gitconfig。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 查看配置信息# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; -l# 查看当前生效的配置信息$ git config -l# 编辑配置文件# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; -e# 添加配置项# --local：仓库级，--global：全局级，--system：系统级$ git config &lt;--local | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;# 获取配置项$ git config &lt;--local | --global | --system&gt; --get &lt;name&gt;# 删除配置项$ git config &lt;--local | --global | --system&gt; --unset &lt;name&gt;# 配置提交记录中的用户信息$ git config --global user.name &lt;用户名&gt;$ git config --global user.email &lt;邮箱地址&gt;# 更改Git缓存区的大小# 如果提交的内容较大，默认缓存较小，提交会失败# 缓存大小单位：B，例如：524288000（500MB）$ git config --global http.postBuffer &lt;缓存大小&gt;# 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态$ git config --global color.ui true# 配置可以缓存密码，默认缓存时间15分钟$ git config --global credential.helper cache# git 输入一次密码后永久记住$ git config --global credential.helper store# 配置密码的缓存时间# 缓存时间单位：秒$ git config --global credential.helper &#x27;cache --timeout=&lt;缓存时间&gt;&#x27;# 配置长期存储密码$ git config --global credential.helper store# 配置忽略文件权限的改变$ git config --global core.filemode false# windows 上忽略回车符差异$ git config --global core.whitespace cr-at-eol git clone 123456# 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下$ git clone &lt;远程仓库的网址&gt;# 指定本地仓库的目录$ git clone &lt;远程仓库的网址&gt; &lt;本地目录&gt;# -b 指定要克隆的分支，默认是master分支$ git clone &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt; git remote 12345678910111213141516171819# 列出已经存在的远程仓库$ git remote# 列出远程仓库的详细信息，在别名后面列出URL地址$ git remote -v$ git remote --verbose# 添加远程仓库$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;# 修改远程仓库的别名$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;# 删除指定名称的远程仓库$ git remote remove &lt;远程仓库的别名&gt;# 修改远程仓库的 URL 地址$ git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt; git branch 1234567891011121314151617181920# 列出本地的所有分支，当前所在分支以 &quot;*&quot; 标出$ git branch# 列出本地的所有分支并显示最后一次提交，当前所在分支以 &quot;*&quot; 标出$ git branch -v# 创建新分支，新的分支基于上一次提交建立$ git branch &lt;分支名&gt;# 修改分支名称# 如果不指定原分支名称则为当前所在分支$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;# 强制修改分支名称$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;# 删除指定的本地分支$ git branch -d &lt;分支名称&gt;# 强制删除指定的本地分支$ git branch -D &lt;分支名称&gt; git checkout 123456789101112# 切换到已存在的指定分支$ git checkout &lt;分支名称&gt;# 创建并切换到指定的分支，保留所有的提交记录# 等同于 &quot;git branch&quot; 和 &quot;git checkout&quot; 两个命令合并$ git checkout -b &lt;分支名称&gt;# 创建并切换到指定的分支，删除所有的提交记录$ git checkout --orphan &lt;分支名称&gt;# 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响$ git checkout &lt;文件路径&gt; git cherry-pick 12# 把已经提交的记录合并到当前分支$ git cherry-pick &lt;commit ID&gt; git fetch 123456# 将远程仓库所有分支的最新版本全部取回到本地$ git fetch &lt;远程仓库的别名&gt;# 将远程仓库指定分支的最新版本取回到本地$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; git diff 12345678910111213141516171819# 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改$ git diff# 比较暂存区中的文件和上次提交时的差异$ git diff --cached$ git diff --staged# 比较当前文件和上次提交时的差异$ git diff HEAD# 查看从指定的版本之后改动的内容$ git diff &lt;commit ID&gt;# 比较两个分支之间的差异$ git diff &lt;分支名称&gt; &lt;分支名称&gt;# 查看两个分支分开后各自的改动内容$ git diff &lt;分支名称&gt;...&lt;分支名称&gt; git pull 从远程仓库获取最新版本并合并到本地。首先会执行 git fetch，然后执行 git merge，把获取的分支的 HEAD 合并到当前分支。 12# 从远程仓库获取最新版本。$ git pull git push 123456# 把本地仓库的分支推送到远程仓库的指定分支$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;# 删除指定的远程仓库的分支$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt; git reset 12345678910111213141516# 重置暂存区，但文件不受影响# 相当于将用 &quot;git add&quot; 命令更新到暂存区的内容撤出暂存区，可以指定文件# 没有指定 commit ID 则默认为当前 HEAD$ git reset [&lt;文件路径&gt;]$ git reset --mixed [&lt;文件路径&gt;]# 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改$ git reset &lt;commit ID&gt;$ git reset --mixed &lt;commit ID&gt;# 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改# 相当于调用 &quot;git reset --mixed&quot; 命令后又做了一次 &quot;git add&quot;$ git reset --soft &lt;commit ID&gt;# 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了$ git reset --hard &lt;commit ID&gt; git tag 123456789101112131415161718192021222324# 打印所有的标签$ git tag# 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录$ git tag &lt;标签名称&gt; [&lt;commit ID&gt;]# 添加带有描述信息的附注标签，可以指定之前的提交记录$ git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]# 切换到指定的标签$ git checkout &lt;标签名称&gt;# 查看标签的信息$ git show &lt;标签名称&gt;# 删除指定的标签$ git tag -d &lt;标签名称&gt;# 将指定的标签提交到远程仓库$ git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;# 将本地所有的标签全部提交到远程仓库$ git push &lt;远程仓库的别名&gt; –tags git mv 12# 重命名指定的文件或者文件夹$ git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt; git rm 12345678# 移除跟踪指定的文件，并从本地仓库的文件夹中删除$ git rm &lt;文件路径&gt;# 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除$ git rm -r &lt;文件夹路径&gt;# 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件$ git rm --cached git 删除远程不存在的分支 ( 协同开发时，其他人删了远程分支 ) 123456# 使用 pull 命令，添加 -p 参数$ git pull -p# 等同于下面的命令$ git fetch -p$ git fetch --prune origin","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[]},{"title":"HEXO Hacker 主题中文说明","slug":"hexo/02_hexo_中文手册","date":"2021-02-07T00:00:00.000Z","updated":"2021-03-09T10:47:23.651Z","comments":true,"path":"2021/02/07/hexo/02_hexo_中文手册/","link":"","permalink":"http://example.com/2021/02/07/hexo/02_hexo_%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/","excerpt":"","text":"Hacker | English Docs Hacker 是一款专注于写作的简洁博客主题。在如此讲究复杂排版的趋势下，选择回归本源，专注于写作这件事。 一开始是 moyo 为 Wordpress 所创作的一个主题，由 CodeDaraW 移植到 Hexo 。 Demo参考我的博客：DaraW。可以使用 TravisCI 实现自动化部署，配置参考 CodeDaraW/Blog。 安装获得主题文件， git clone 或者 download zip 均可； 在 themes 文件夹中创建文件夹 Hacker ，将主题文件都复制粘贴至 Hacker 文件夹； 然后在hexo全局配置文件 _config.yml 中应用主题： 1theme: Hacker 这样就安装好了，开始享受吧~ 注意：版本更新后建议在hexo生成前执行一次 hexo clean ，清除以前的缓存，避免带来的一些莫名其妙的问题。 配置启用评论和谷歌分析参考 _config.example.yml 配置案例，创建主题配置文件 _config.yml 并编辑： 1234567891011121314151617181920212223242526272829# gitmentgitment: falsegitment_owner:gitment_repo:gitment_client_id:gitment_client_secret:# gitalkgitalk: falsegitalk_owner:gitalk_admin: []gitalk_repo:gitalk_client_id:gitalk_client_secret:# valine commentvaline: falseleancloud_id:leancloud_key:# disqus commentdisqus: falsedisqus_shortname:# google analyticsgoogleTrackId:# baidu analyticsbaiduTrackId: gitment: boolean，是否开启 Gitment 评论gitment_owner: string，你的 GitHub IDgitment_repo: string，存储评论的 Repogitment_client_id: string，你的 Client IDgitment_client_secret: string，你的 Client Secret gitalk: boolean，是否开启 Gitalk 评论gitalk_owner: string，你的 GitHub IDgitalk_admin: array，所有管理员 GitHub IDgitalk_repo: string，存储评论的 Repogitalk_client_id: string，你的 Client IDgitalk_client_secret: string，你的 Client Secret valine: boolean，是否开启 Valine 评论leancloud_id: string，你的 LeanCloud IDleancloud_key: string，你的 LeanCloud Key disqus: boolean，是否开启 Disqus 评论；disqus_shortname: string，你的 Disqus Site Shortname。 googleTrackId: string，为谷歌分析的个人ID，留空则为不使用谷歌分析。baiduTrackId: string, 为百度统计的个人ID,留空则为不是用谷歌分析。 启用分类和标签页面分类功能：执行 hexo new page categories ，然后修改生成的 source/categories/index.md ： 1234title: categoriesdate: 2017-01-30 19:16:17layout: &quot;categories&quot;--- 如果你需要关闭该页的评论，可以添加一行 comments: false；title 对应的则是该页的标题。 标签功能：同理，执行 hexo new page tags ，然后修改生成的 source/tags/index.md ： 1234title: tagsdate: 2017-01-30 19:16:17layout: &quot;tags&quot;--- 配置同分类功能。 在菜单中添加链接：编辑主题的 _config.yml ，在 menu 中添加 Categories: /categories 和 Tags: /tags，如下： 12345menu: Home: / Archives: /archives Categories: /categories Tags: /tags 协议GNU GPL(General Public License) v2.0","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"UEFI Protocol 机制","slug":"uefi/04_UFEI_protocol","date":"2021-02-07T00:00:00.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"2021/02/07/uefi/04_UFEI_protocol/","link":"","permalink":"http://example.com/2021/02/07/uefi/04_UFEI_protocol/","excerpt":"","text":"Protocol GUID是一条链表，每个节点是就是一个GUID，一个GUID必须挂一条 Protocol.","categories":[{"name":"uefi","slug":"uefi","permalink":"http://example.com/categories/uefi/"}],"tags":[]},{"title":"MarkDown Language Reference","slug":"markdown/03_language_markdown_ref","date":"2021-02-07T00:00:00.000Z","updated":"2021-03-09T10:47:23.651Z","comments":true,"path":"2021/02/07/markdown/03_language_markdown_ref/","link":"","permalink":"http://example.com/2021/02/07/markdown/03_language_markdown_ref/","excerpt":"","text":"一级标题 二级标题 三级标题 四级标题 五级标题 ###### 六级标题 代码块 表格 | 单元格 | 单元格 | 红色字体 注释 ~~~ 任务列表 - [x] 任务二 已做任务 - + 空格 + [x] 换行 (后面空2格) 空行 对齐方式 斜体、粗体、删除线、下划线、背景高亮 超链接、页内链接、自动链接 注脚 自动链接 插图片 多级引用 字体、字号、颜色 流程图 分割线 HTML表单 特殊字符 目录 Markdown All in One: Create Table of Contents 标题一级标题二级标题三级标题四级标题五级标题六级标题 代码块$符，加行号 1$ int a = 4 ; VS 1int a = 4 ; 表格 表头 表头 单元格 单元格 单元格 单元格 红色字体 注释123&lt;div style=&#x27;display: none&#x27;&gt;哈哈我是注释，不会在浏览器中显示。&lt;/div&gt; 任务列表 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 换行 (后面空2格)nihaofaweafe 空行在编辑的时候有多少个空行(只要这一行只有回车或者space没有其他的字符就算空行)，在渲染之后，只隔着一行。 对齐方式行中心对齐 行左对齐 行右对齐 斜体、粗体、删除线、下划线、背景高亮斜体或斜体粗体加粗斜体删除线++下划线++==背景高亮== 超链接、页内链接、自动链接 方法一[]里写链接文字，()里写链接地址, ()中的””中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字，链接地址与title前有一个空格。 作者：择势量投链接：https://www.jianshu.com/p/ebe52d2d468f来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。欢迎阅读 择势勤 方法二我经常去的几个网站Google、Leanote。 注脚使用 Markdown^1可以效率的书写文档, 直接转换成 HTML[^2]。 [^2]:HyperText Markup Language 超文本标记语言 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：&lt;http://example.com/&gt; &emsp;&emsp;&lt;&#x61;&#100;&#100;&#x72;&#x65;&#x73;&#x73;&#64;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;&gt; 插图片 _config.yml 中配置 post_asset_folder: true 在md文件同级目录建立同名文件夹，将图片放入，就可以相对的引用1![](patchbinary.png) 多级引用 请问 Markdwon 怎么用？ - 小白自己看教程！ - 愤青教程在哪？ - 小白 字体、字号、颜色123456&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;&#x2F;font&gt;&lt;font color&#x3D;#0099ff size&#x3D;12 face&#x3D;&quot;黑体&quot;&gt;黑体&lt;&#x2F;font&gt;&lt;font color&#x3D;gray size&#x3D;5&gt;gray&lt;&#x2F;font&gt;&lt;font color&#x3D;#00ffff size&#x3D;3&gt;null&lt;&#x2F;font&gt; 我是黑体字我是微软雅黑我是华文彩云黑体graynull 流程图12graph LRA--&gt;B 123sequenceDiagramA-&gt;&gt;B: How are you?B-&gt;&gt;A: Great! 分割线 HTML表单 值班人员 星期一 星期二 星期三 李强 张明 王平 特殊字符 表头 表头 单元格 单元格 单元格 单元格 ｜特殊字符 | 描述 | 字符的代| | —- | —- | —- |｜ | 空格符 | &nbsp;|｜&lt; | 小于号 | &lt; |｜ &gt; | 大于号 | &gt; |｜&amp; | 和号 | &amp;|｜￥ | 人民币 | &yen;|｜© | 版权 | &copy;|｜® | 注册商标 | &reg;|｜°C | 摄氏度 | &deg;|｜± | 正负号 | &plusmn;|｜× | 乘号 | &times;|｜÷ | 除号 | &divide;|｜² | 平方（上标²）| &sup2;|｜³ | 立方（上标³）| &sup3;|","categories":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/categories/markdown/"}],"tags":[]},{"title":"UEFI hello world 模块","slug":"uefi/hello_world","date":"2021-02-07T00:00:00.000Z","updated":"2021-03-09T10:47:23.655Z","comments":true,"path":"2021/02/07/uefi/hello_world/","link":"","permalink":"http://example.com/2021/02/07/uefi/hello_world/","excerpt":"","text":"目的 EFI shell 中运行 helloworld.efi，执行我们写的驱动 c文件 放在某个pkg下: OvmfPkg\\HelloWorld\\HelloWorld.c 123456789101112131415161718192021#include &lt;uefi.h&gt; #include &lt;Library/UefiLib.h&gt; #include &lt;Library/BaseLib.h&gt;#include &lt;Library/DebugLib.h&gt;#include &lt;Library/BaseMemoryLib.h&gt;#include &lt;Library/UefiBootServicesTableLib.h&gt;//ShellCEntryLib call user interface ShellAppMainEFI_STATUSEFIAPIHelloWorldEntry( IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable)&#123; EFI_STATUS Status = EFI_SUCCESS; Print (L&quot;[Console] HelloWorldEntry Start..\\n&quot;); Print (L&quot;[Console] HelloWorldEntry End ... \\n&quot;); return Status;&#125; 同级目录下添加构建文件 ：OvmfPkg\\HelloWorld\\HelloWorld.inf 1234567891011121314151617181920212223242526[Defines] [Defines] INF_VERSION = 0x00010007 BASE_NAME = HelloWorld FILE_GUID = 69A6DE6D-FA9F-485E-9A4E-EA70FDCFD82F MODULE_TYPE = UEFI_APPLICATION VERSION_STRING = 1.0 ENTRY_POINT = HelloWorldEntry [Sources] HelloWorld.c [Packages] MdePkg/MdePkg.dec ShellPkg/ShellPkg.dec MdeModulePkg/MdeModulePkg.dec [LibraryClasses] UefiShellCEntryLib BaseLib BaseMemoryLib DebugLib PrintLib UefiBootServicesTableLib MemoryAllocationLib UefiLib 在项目对应的DSC中添加如下内容：OvmfPkg\\OvmfPkgX64.dsc 1234...[Components] OvmfPkg/HelloWorld/HelloWorld.inf... 此时编译整个项目就可以编译到我们的模块运行edksetup.bat编译整个OvmfPkg Packagebuild -a X64 -p OvmfPkg\\OvmfPkgX64.dsc -D DEBUG_ON_SERIAL_PORT","categories":[{"name":"uefi","slug":"uefi","permalink":"http://example.com/categories/uefi/"}],"tags":[]}],"categories":[{"name":"bios","slug":"bios","permalink":"http://example.com/categories/bios/"},{"name":"tools","slug":"tools","permalink":"http://example.com/categories/tools/"},{"name":"liveoverflow","slug":"liveoverflow","permalink":"http://example.com/categories/liveoverflow/"},{"name":"vscode","slug":"vscode","permalink":"http://example.com/categories/vscode/"},{"name":"c","slug":"c","permalink":"http://example.com/categories/c/"},{"name":"PCI","slug":"PCI","permalink":"http://example.com/categories/PCI/"},{"name":"uefi","slug":"uefi","permalink":"http://example.com/categories/uefi/"},{"name":"vim","slug":"vim","permalink":"http://example.com/categories/vim/"},{"name":"interview","slug":"interview","permalink":"http://example.com/categories/interview/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/categories/markdown/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}